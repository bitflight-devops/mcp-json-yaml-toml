---
phase: 01-architectural-foundation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp_json_yaml_toml/services/__init__.py
  - packages/mcp_json_yaml_toml/services/pagination.py
  - packages/mcp_json_yaml_toml/server.py
autonomous: true
must_haves:
  truths:
    - "Pagination logic exists in services/pagination.py as a dedicated module"
    - "server.py imports pagination functions from services.pagination"
    - "server.py re-exports _encode_cursor, _decode_cursor, _paginate_result for backward compatibility"
    - "All 395 existing tests pass without modification (including test_pagination.py)"
  artifacts:
    - path: "packages/mcp_json_yaml_toml/services/__init__.py"
      provides: "Package marker for services module"
    - path: "packages/mcp_json_yaml_toml/services/pagination.py"
      provides: "Cursor encoding/decoding, paginate_result, structure summarization, pagination hints"
      exports:
        [
          "_encode_cursor",
          "_decode_cursor",
          "_paginate_result",
          "_summarize_structure",
          "_get_pagination_hint",
          "PAGE_SIZE_CHARS",
          "ADVISORY_PAGE_THRESHOLD",
          "MAX_PRIMITIVE_DISPLAY_LENGTH",
        ]
    - path: "packages/mcp_json_yaml_toml/server.py"
      provides: "Re-exports pagination functions from services.pagination for backward compatibility"
      contains: "from mcp_json_yaml_toml.services.pagination import"
  key_links:
    - from: "packages/mcp_json_yaml_toml/services/pagination.py"
      to: "packages/mcp_json_yaml_toml/server.py"
      via: "server.py imports and re-exports pagination functions"
      pattern: "from mcp_json_yaml_toml\\.services\\.pagination import"
    - from: "packages/mcp_json_yaml_toml/tests/test_pagination.py"
      to: "packages/mcp_json_yaml_toml/server.py"
      via: "test_pagination.py imports _encode_cursor, _decode_cursor, _paginate_result from server"
      pattern: "from mcp_json_yaml_toml\\.server import _encode_cursor"
---

<objective>
Extract pagination logic from server.py into services/pagination.py.

Purpose: Pagination (cursor encoding/decoding, result chunking, structure summarization, advisory hints) is a self-contained utility with no dependencies on server business logic. Extracting it into services/pagination.py reduces server.py complexity and creates a focused, testable module. test_pagination.py already imports these functions from server -- the re-export ensures backward compatibility (Success Criterion 5).

Output: services/ package with pagination.py containing all pagination logic. server.py reduced by ~170 lines with re-exports maintaining import compatibility.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-architectural-foundation/01-RESEARCH.md
@.planning/codebase/CONVENTIONS.md
@.planning/codebase/ARCHITECTURE.md
@packages/mcp_json_yaml_toml/server.py
@packages/mcp_json_yaml_toml/tests/test_pagination.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create services/pagination.py with extracted pagination logic</name>
  <files>
    packages/mcp_json_yaml_toml/services/__init__.py
    packages/mcp_json_yaml_toml/services/pagination.py
  </files>
  <action>
Create the `services/` package directory under `packages/mcp_json_yaml_toml/`.

**services/**init**.py**: Empty package marker with a module docstring:

```python
"""Service modules extracted from server.py."""
```

**services/pagination.py**: Extract the following functions and constants from `server.py`:

**Constants (lines 130-133 of server.py):**

- `PAGE_SIZE_CHARS = 10000`
- `ADVISORY_PAGE_THRESHOLD = 2`
- `MAX_PRIMITIVE_DISPLAY_LENGTH = 200`

**Core pagination functions (lines ~134-215 of server.py):**

- `_encode_cursor(offset: int) -> str` -- base64 encode pagination cursor
- `_decode_cursor(cursor: str) -> int` -- base64 decode pagination cursor
- `_paginate_result(result: str, cursor: str | None = None) -> dict[str, Any]` -- chunk result by PAGE_SIZE_CHARS with cursor-based navigation

**Structure summarization functions (lines ~218-600 of server.py):**

- `_summarize_structure(data: Any, ...) -> str` -- recursively summarize data structure
- `_summarize_list_structure(data: list, ...) -> str` -- list-specific summarization
- `_summarize_depth_exceeded(data: Any) -> str` -- depth limit handler
- `_summarize_primitive(value: Any) -> str` -- primitive value summarization

**Pagination hint function (search for `_get_pagination_hint` in server.py):**

- `_get_pagination_hint(result: str, ...) -> str | None` -- advisory hint for multi-page results

Dependencies of these functions: `base64`, `orjson`, `typing.Any` -- all standard library or existing project dependencies. NO project-internal imports needed. This module is fully self-contained.

Follow project conventions: `from __future__ import annotations` first, Google-style docstrings, type annotations. Define `__all__` listing all public exports.

Read server.py carefully to identify the exact function boundaries. Some helper functions used ONLY by pagination logic should move too. Functions that are used by BOTH pagination and non-pagination code should be examined: if a function is called from \_paginate_result or \_get_pagination_hint and from nowhere else in server.py, it belongs in pagination.py. If it's shared, leave it in server.py and import it in pagination.py (though based on research, pagination functions have no cross-dependencies).

IMPORTANT: Preserve exact function signatures and return types. test_pagination.py tests specific behavior of \_encode_cursor, \_decode_cursor, and \_paginate_result. Any signature change will break tests.
</action>
<verify>
Run: `python -c "from mcp_json_yaml_toml.services.pagination import _encode_cursor, _decode_cursor, _paginate_result, PAGE_SIZE_CHARS; print('All imports OK')"` -- must succeed.

Run: `uv run ruff check packages/mcp_json_yaml_toml/services/` -- must pass.

Run: `uv run ruff format --check packages/mcp_json_yaml_toml/services/` -- must pass.
</verify>
<done>
services/pagination.py exists with all pagination constants, cursor functions, structure summarization, and hint functions extracted from server.py. Module imports successfully.
</done>
</task>

<task type="auto">
  <name>Task 2: Update server.py to import from services.pagination and re-export</name>
  <files>packages/mcp_json_yaml_toml/server.py</files>
  <action>
Modify server.py to use the extracted pagination module:

1. **Remove** the extracted function definitions and constants from server.py (the code that was copied to services/pagination.py in Task 1).

2. **Add import** at the top of server.py (in the local imports section):

```python
from mcp_json_yaml_toml.services.pagination import (
    ADVISORY_PAGE_THRESHOLD,
    MAX_PRIMITIVE_DISPLAY_LENGTH,
    PAGE_SIZE_CHARS,
    _decode_cursor,
    _encode_cursor,
    _get_pagination_hint,
    _paginate_result,
    _summarize_structure,
)
```

Include all functions/constants that server.py's remaining code references.

3. **Verify re-export**: The import statement above makes these names available as `server._encode_cursor`, etc. This preserves backward compatibility for test_pagination.py which imports `from mcp_json_yaml_toml.server import _encode_cursor, _decode_cursor, _paginate_result`.

Note: Python's import mechanism automatically makes imported names attributes of the importing module. No additional `__all__` change in server.py is needed for backward compatibility. BUT verify that the imports appear as top-level names in server.py's namespace (they will, since they're direct imports).

4. **Check server.py's remaining code** still compiles and references the pagination functions correctly. The remaining tool functions (`data_query`, `data`, etc.) call `_paginate_result` and `_get_pagination_hint` -- these now resolve via the import from services.pagination.

Run the quality gates on the modified server.py: `uv run prek run --files packages/mcp_json_yaml_toml/server.py packages/mcp_json_yaml_toml/services/pagination.py`
</action>
<verify>
Run: `uv run pytest -x -q` -- all 395 tests must pass.

Specifically verify backward compatibility: `python -c "from mcp_json_yaml_toml.server import _encode_cursor, _decode_cursor, _paginate_result; print('Backward compat OK')"` -- must succeed.

Run: `uv run pytest packages/mcp_json_yaml_toml/tests/test_pagination.py -v` -- all pagination tests must pass.

Run: `uv run mypy packages/mcp_json_yaml_toml/server.py packages/mcp_json_yaml_toml/services/ --show-error-codes` -- must pass.

Run: `uv run basedpyright packages/mcp_json_yaml_toml/server.py packages/mcp_json_yaml_toml/services/` -- must pass.
</verify>
<done>
server.py no longer contains pagination function definitions (reduced by ~170 lines). Pagination functions imported from services.pagination. All 395 tests pass including test_pagination.py importing from server. Type checkers pass on both files. ARCH-01 requirement satisfied.
</done>
</task>

</tasks>

<verification>
1. `python -c "from mcp_json_yaml_toml.services.pagination import _encode_cursor, _decode_cursor, _paginate_result"` succeeds
2. `python -c "from mcp_json_yaml_toml.server import _encode_cursor, _decode_cursor, _paginate_result"` succeeds (backward compat)
3. `uv run pytest -x -q` -- all 395 tests pass
4. `uv run pytest packages/mcp_json_yaml_toml/tests/test_pagination.py -v` -- all pagination tests pass
5. `wc -l packages/mcp_json_yaml_toml/server.py` -- reduced by ~170 lines from 1880
6. Type checkers pass on server.py and services/
</verification>

<success_criteria>

- services/pagination.py contains all pagination logic (constants, cursor functions, summarization, hints)
- server.py imports from services.pagination (no longer defines pagination functions inline)
- test_pagination.py continues to import from server.py without changes and all tests pass
- All 395 tests pass without modification
- server.py line count reduced by approximately 170 lines
  </success_criteria>

<output>
After completion, create `.planning/phases/01-architectural-foundation/01-02-SUMMARY.md`
</output>
