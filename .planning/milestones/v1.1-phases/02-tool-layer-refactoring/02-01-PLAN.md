---
phase: 02-tool-layer-refactoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp_json_yaml_toml/models/__init__.py
  - packages/mcp_json_yaml_toml/models/responses.py
  - packages/mcp_json_yaml_toml/services/schema_validation.py
  - packages/mcp_json_yaml_toml/server.py
autonomous: true

must_haves:
  truths:
    - "Pydantic response models exist for all tool return shapes"
    - "Schema validation logic exists in a standalone service module"
    - "All 395 existing tests pass without modification"
  artifacts:
    - path: "packages/mcp_json_yaml_toml/models/__init__.py"
      provides: "Package marker for models"
    - path: "packages/mcp_json_yaml_toml/models/responses.py"
      provides: "All Pydantic response models for tool returns"
      contains: "class ToolResponse"
    - path: "packages/mcp_json_yaml_toml/services/schema_validation.py"
      provides: "JSON Schema validation logic extracted from server.py"
      contains: "_validate_against_schema"
  key_links:
    - from: "packages/mcp_json_yaml_toml/models/responses.py"
      to: "pydantic.BaseModel"
      via: "inheritance"
      pattern: "class.*BaseModel"
    - from: "packages/mcp_json_yaml_toml/services/schema_validation.py"
      to: "jsonschema"
      via: "Draft7Validator and Draft202012Validator"
      pattern: "Draft7Validator|Draft202012Validator"
---

<objective>
Create Pydantic response models and extract schema validation service.

Purpose: Establish the foundation types that tools and services will use in subsequent plans.
Response models enable typed return values (FMCP-04 foundation). Schema validation extraction
is a low-risk first move — no test imports this function directly, so it can be moved without
any backward compatibility concern.

Output: models/responses.py with all response models, services/schema_validation.py with
validation logic, server.py updated to import from new locations.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tool-layer-refactoring/02-RESEARCH.md
@packages/mcp_json_yaml_toml/server.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic response models and schema validation service</name>
  <files>
    packages/mcp_json_yaml_toml/models/__init__.py
    packages/mcp_json_yaml_toml/models/responses.py
    packages/mcp_json_yaml_toml/services/schema_validation.py
  </files>
  <action>
**Create `models/__init__.py`:**
Empty package marker (single docstring line).

**Create `models/responses.py`:**
Define all Pydantic response models. Use `from __future__ import annotations`. Import BaseModel, Field from pydantic. Import SchemaInfo from `mcp_json_yaml_toml.schemas`. Import Any from typing.

Models to create (derive field names and types from the current dict returns in server.py):

1. `ToolResponse(BaseModel)` — base with `success: bool`, `file: str | None = None`
2. `DataResponse(ToolResponse)` — for data GET and data_query returns: `result: Any`, `format: str`, `paginated: bool = False`, `nextCursor: str | None = None`, `advisory: str | None = None`, `schema_info: SchemaInfo | None = None`, `structure_summary: str | None = None`
3. `MutationResponse(ToolResponse)` — for data SET/DELETE: `result: str`, `optimized: bool = False`, `message: str | None = None`, `schema_info: SchemaInfo | None = None`
4. `ValidationResponse(ToolResponse)` — for data_schema validate action: `format: str | None = None`, `syntax_valid: bool = False`, `schema_validated: bool = False`, `syntax_message: str | None = None`, `schema_message: str | None = None`, `schema_file: str | None = None`, `overall_valid: bool = False`
5. `SchemaActionResponse(ToolResponse)` — for data_schema other actions: `action: str`, `message: str | None = None`, `schemas: list[dict[str, Any]] | None = None`, `directories: list[str] | None = None`, `catalogs: list[str] | None = None`, `associations: dict[str, Any] | None = None`
6. `ConvertResponse(ToolResponse)` — for data_convert: `input_file: str`, `input_format: str`, `output_format: str`, `result: str | None = None`, `output_file: str | None = None`, `message: str | None = None`
7. `MergeResponse(ToolResponse)` — for data_merge: `file1: str`, `file2: str`, `output_format: str`, `result: str | None = None`, `output_file: str | None = None`, `message: str | None = None`
8. `ConstraintValidateResponse(BaseModel)` — NOT inheriting ToolResponse (different shape): `valid: bool`, `constraint: str`, `value: str`, `error: str | None = None`, `is_partial: bool | None = None`, `hint: str | None = None`
9. `ConstraintListResponse(BaseModel)` — `constraints: list[dict[str, Any]]`, `usage: str`

Move the existing `SchemaResponse` model from server.py (lines 71-81) into responses.py. Keep its `schema_` field with `Field(default=None, alias="schema")` and `model_config = {"populate_by_name": True}`.

All models should use `model_config = {"extra": "allow"}` on the base `ToolResponse` class to prevent breakage from any fields the current code includes that we haven't enumerated. This is a safety net during refactoring — it can be tightened to `"forbid"` after all tests pass in Plan 04.

Add `__all__` listing all model names for explicit exports.

**Create `services/schema_validation.py`:**
Extract `_validate_against_schema()` from server.py (lines 582-640). This function:

- Takes `path: Path`, `content: str`, `schema_info: SchemaInfo`, `input_format: FormatType | str` parameters
- Uses `httpx`, `orjson`, `jsonschema` (Draft7Validator, Draft202012Validator), `referencing` (Registry, Resource), `referencing.exceptions` (NoSuchResource)
- Uses `_parse_content_for_validation` from `formats.base`
- Returns `dict[str, Any]` with validation results

Move the function exactly as-is. Add the required imports at the top. Use `from __future__ import annotations`. Add an `__all__` export list.

Do NOT modify server.py in this task. That happens in Task 2.
</action>
<verify>
uv run python -c "from mcp_json_yaml_toml.models.responses import ToolResponse, DataResponse, SchemaResponse, ConstraintValidateResponse; print('Models OK')"
uv run python -c "from mcp_json_yaml_toml.services.schema_validation import \_validate_against_schema; print('Schema validation OK')"
uv run ruff check packages/mcp_json_yaml_toml/models/ packages/mcp_json_yaml_toml/services/schema_validation.py
</verify>
<done>
All response models importable from models.responses. SchemaResponse includes alias for schema field.
\_validate_against_schema importable from services.schema_validation. Ruff clean.
</done>
</task>

<task type="auto">
  <name>Task 2: Update server.py to import from new locations</name>
  <files>
    packages/mcp_json_yaml_toml/server.py
  </files>
  <action>
**Update server.py imports:**

1. Remove the `SchemaResponse` class definition (lines 71-81) from server.py.
2. Add import: `from mcp_json_yaml_toml.models.responses import SchemaResponse  # noqa: F401` (re-export for backward compat — tests may reference `server.SchemaResponse`).
3. Remove the `_validate_against_schema` function body from server.py (lines 582-640).
4. Add import: `from mcp_json_yaml_toml.services.schema_validation import _validate_against_schema` (used by schema tool handlers still in server.py).
5. Remove imports from server.py that are now only used in `services/schema_validation.py` and not elsewhere in server.py: check each of `httpx`, `Draft7Validator`, `Draft202012Validator`, `SchemaError`, `ValidationError`, `Registry`, `Resource`, `NoSuchResource` — only remove if no other code in server.py uses them. IMPORTANT: `httpx` is also used by `_handle_schema_add_catalog` (line ~1100 area), and `SchemaError`/`ValidationError` may be used elsewhere. Verify each import is truly unused before removing.

**Critical:** After these changes, run `uv run pytest -x` to confirm all tests pass. The function is being moved, not changed — behavior is identical.
</action>
<verify>
uv run python -c "from mcp_json_yaml_toml import server; print(hasattr(server, 'SchemaResponse'))"
uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q
uv run ruff check packages/mcp_json_yaml_toml/server.py
uv run mypy packages/mcp_json_yaml_toml/server.py packages/mcp_json_yaml_toml/models/ packages/mcp_json_yaml_toml/services/schema_validation.py --show-error-codes
</verify>
<done>
SchemaResponse removed from server.py body, importable via server.SchemaResponse re-export.
\_validate_against_schema removed from server.py body, imported from services.schema_validation.
All 395 tests pass. Ruff and mypy clean on modified files.
</done>
</task>

</tasks>

<verification>
- `uv run pytest packages/mcp_json_yaml_toml/tests/ -q` — all tests pass
- `uv run ruff check packages/mcp_json_yaml_toml/` — clean
- `uv run mypy packages/ --show-error-codes` — no new errors
- `from mcp_json_yaml_toml.models.responses import *` imports all 9+ models
- `from mcp_json_yaml_toml.services.schema_validation import _validate_against_schema` works
- `server.SchemaResponse` is accessible (backward compat)
</verification>

<success_criteria>

- models/responses.py exists with all Pydantic response models
- services/schema_validation.py exists with \_validate_against_schema
- server.py no longer defines SchemaResponse or \_validate_against_schema
- All 395 tests pass without modification
  </success_criteria>

<output>
After completion, create `.planning/phases/02-tool-layer-refactoring/02-01-SUMMARY.md`
</output>
