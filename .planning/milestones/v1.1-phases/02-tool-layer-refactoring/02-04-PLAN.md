---
phase: 02-tool-layer-refactoring
plan: 04
type: execute
wave: 4
depends_on: ["02-03"]
files_modified:
  - packages/mcp_json_yaml_toml/tools/data.py
  - packages/mcp_json_yaml_toml/tools/query.py
  - packages/mcp_json_yaml_toml/tools/schema.py
  - packages/mcp_json_yaml_toml/tools/convert.py
  - packages/mcp_json_yaml_toml/tools/constraints.py
  - packages/mcp_json_yaml_toml/services/data_operations.py
autonomous: true

must_haves:
  truths:
    - "All tools have complete MCP annotations (readOnlyHint, destructiveHint, idempotentHint)"
    - "Tools with single response shapes return Pydantic response models"
    - "Internal handlers return Pydantic models where practical"
    - "All 395 existing tests pass without modification"
  artifacts:
    - path: "packages/mcp_json_yaml_toml/tools/data.py"
      provides: "data tool with destructiveHint=True, idempotentHint=True annotations"
      contains: "destructiveHint"
    - path: "packages/mcp_json_yaml_toml/tools/query.py"
      provides: "data_query tool returning DataResponse with readOnlyHint=True, idempotentHint=True"
      contains: "idempotentHint"
    - path: "packages/mcp_json_yaml_toml/tools/schema.py"
      provides: "data_schema tool with idempotentHint=True, openWorldHint=True"
      contains: "openWorldHint"
    - path: "packages/mcp_json_yaml_toml/tools/convert.py"
      provides: "data_convert/data_merge with readOnlyHint=True, idempotentHint=True"
      contains: "idempotentHint"
    - path: "packages/mcp_json_yaml_toml/tools/constraints.py"
      provides: "constraint tools with readOnlyHint=True, idempotentHint=True"
      contains: "idempotentHint"
  key_links:
    - from: "packages/mcp_json_yaml_toml/tools/query.py"
      to: "packages/mcp_json_yaml_toml/models/responses.py"
      via: "return type annotation"
      pattern: "-> DataResponse"
    - from: "packages/mcp_json_yaml_toml/tools/constraints.py"
      to: "packages/mcp_json_yaml_toml/models/responses.py"
      via: "return type annotation"
      pattern: "-> ConstraintValidateResponse|-> ConstraintListResponse"
---

<objective>
Add complete MCP tool annotations and Pydantic return types to all tools.

Purpose: Complete FMCP-04 (Pydantic response models) and FMCP-05 (tool annotations) requirements.
This is the final behavioral change in Phase 2 — prior plans were structural moves. Pydantic return
types enable FastMCP to auto-generate output_schema for MCP clients (foundation for Phase 3
structured output). Complete annotations inform MCP clients about tool behavior semantics.

Output: All tools annotated, single-shape tools returning Pydantic models.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-tool-layer-refactoring/02-RESEARCH.md
@.planning/phases/02-tool-layer-refactoring/02-03-SUMMARY.md
@packages/mcp_json_yaml_toml/tools/data.py
@packages/mcp_json_yaml_toml/tools/query.py
@packages/mcp_json_yaml_toml/tools/schema.py
@packages/mcp_json_yaml_toml/tools/convert.py
@packages/mcp_json_yaml_toml/tools/constraints.py
@packages/mcp_json_yaml_toml/models/responses.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add complete annotations to all tools</name>
  <files>
    packages/mcp_json_yaml_toml/tools/data.py
    packages/mcp_json_yaml_toml/tools/query.py
    packages/mcp_json_yaml_toml/tools/schema.py
    packages/mcp_json_yaml_toml/tools/convert.py
    packages/mcp_json_yaml_toml/tools/constraints.py
  </files>
  <action>
Update every `@mcp.tool()` decorator to include complete annotations. Use the dict form
(already established in codebase) rather than importing `ToolAnnotations`.

**Annotation assignments (from research section 10):**

**tools/data.py — `data` tool:**

```python
@mcp.tool(annotations={
    "readOnlyHint": False,
    "destructiveHint": True,
    "idempotentHint": True,
    "openWorldHint": False,
})
```

Rationale: set/delete operations modify files (not read-only, destructive). Same set/delete with same args = same result (idempotent). Operates only on local filesystem (not open-world).

**tools/query.py — `data_query` tool:**

```python
@mcp.tool(annotations={
    "readOnlyHint": True,
    "destructiveHint": False,
    "idempotentHint": True,
    "openWorldHint": False,
})
```

Currently has `readOnlyHint=True`. Add the other three.

**tools/schema.py — `data_schema` tool:**

```python
@mcp.tool(annotations={
    "readOnlyHint": False,
    "destructiveHint": False,
    "idempotentHint": True,
    "openWorldHint": True,
})
```

Rationale: associate/add_dir/add_catalog modify in-memory config (not read-only). Modifications are additive, not destructive. Re-doing any action produces same state (idempotent). validate/scan may access Schema Store via httpx (open-world).

**tools/convert.py — `data_convert` tool:**

```python
@mcp.tool(annotations={
    "readOnlyHint": True,
    "destructiveHint": False,
    "idempotentHint": True,
    "openWorldHint": False,
})
```

Keep readOnlyHint=True per research recommendation (primary use case is read-only conversion, output_file is optional secondary feature). Add the others.

**tools/convert.py — `data_merge` tool:**

```python
@mcp.tool(annotations={
    "readOnlyHint": True,
    "destructiveHint": False,
    "idempotentHint": True,
    "openWorldHint": False,
})
```

Same rationale as data_convert.

**tools/constraints.py — `constraint_validate` tool:**

```python
@mcp.tool(annotations={
    "readOnlyHint": True,
    "destructiveHint": False,
    "idempotentHint": True,
    "openWorldHint": False,
})
```

Currently has readOnlyHint=True. Add the other three.

**tools/constraints.py — `constraint_list` tool:**

```python
@mcp.tool(annotations={
    "readOnlyHint": True,
    "destructiveHint": False,
    "idempotentHint": True,
    "openWorldHint": False,
})
```

Currently has readOnlyHint=True. Add the other three.
</action>
<verify>
uv run python -c "
from mcp_json_yaml_toml import server
tools = server.mcp.\_tool_manager.\_tools
for name, tool in tools.items():
ann = tool.annotations if hasattr(tool, 'annotations') else None
print(f'{name}: {ann}')
"
uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q
uv run ruff check packages/mcp_json_yaml_toml/tools/
</verify>
<done>
All 7 tools have complete annotations with all four hint fields specified.
All 395 tests pass. Ruff clean.
</done>
</task>

<task type="auto">
  <name>Task 2: Add Pydantic return types to single-shape tools</name>
  <files>
    packages/mcp_json_yaml_toml/tools/query.py
    packages/mcp_json_yaml_toml/tools/convert.py
    packages/mcp_json_yaml_toml/tools/constraints.py
    packages/mcp_json_yaml_toml/services/data_operations.py
  </files>
  <action>
Add Pydantic model return types to tools with a single, consistent response shape. The `data` tool
and `data_schema` tool have polymorphic responses (shape varies by operation) — they keep returning
`dict[str, Any]` per the research recommendation (Option 4). The internal handlers will return
response models, calling `.model_dump(exclude_none=True)` at the tool boundary.

**tools/query.py — update `data_query` return type:**

1. Import `DataResponse` from `mcp_json_yaml_toml.models.responses`
2. Update `_build_query_response` in `services/data_operations.py` to construct and return a `DataResponse` model instead of a raw dict. Use `DataResponse(success=True, result=..., file=..., format=..., ...)`.
3. Update `data_query()` tool function return type to `-> DataResponse`
4. The `_build_query_response` should return a `DataResponse` instance. The `data_query` tool just returns what `_build_query_response` returns.

**CRITICAL COMPATIBILITY:** The current tests check response dict keys. `DataResponse.model_dump(exclude_none=True)` must produce the exact same dict shape. Verify by checking field names match the current dict keys in `_build_query_response`. Watch for these potential mismatches:

- `nextCursor` in current dicts must map to a field named `nextCursor` (not `next_cursor`). Use camelCase field names in the model to match existing behavior, OR use `serialization_alias` if snake_case is preferred. Simplest approach: use `nextCursor` as the field name directly.
- Fields that are currently only included when truthy (e.g., `advisory` only present when not None) — `exclude_none=True` handles this.

**tools/convert.py — update `data_convert` and `data_merge` return types:**

1. Import `ConvertResponse`, `MergeResponse` from models.responses
2. Update `data_convert()` to construct and return `ConvertResponse(...)` instead of raw dict
3. Update `data_merge()` to construct and return `MergeResponse(...)` instead of raw dict
4. Add return type annotations: `-> ConvertResponse`, `-> MergeResponse`

**tools/constraints.py — update constraint tool return types:**

1. Import `ConstraintValidateResponse`, `ConstraintListResponse` from models.responses
2. Update `constraint_validate()` to construct and return `ConstraintValidateResponse(...)` instead of raw dict
3. Update `constraint_list()` to construct and return `ConstraintListResponse(...)` instead of raw dict
4. Add return type annotations: `-> ConstraintValidateResponse`, `-> ConstraintListResponse`

**services/data_operations.py — update `_build_query_response`:**

1. Import `DataResponse` from models.responses
2. Change `_build_query_response` to return `DataResponse` instead of `dict[str, Any]`
3. Construct `DataResponse(...)` at the return points instead of building a dict

**For each conversion, verify the field names in the dict match the Pydantic model field names EXACTLY.** Read the current function body, list all dict keys it produces, and confirm each key has a matching field in the model. If there's a mismatch, update the model in `models/responses.py` (not the existing code).

**Testing approach:** After each tool conversion, run `uv run pytest -x -k "test_name"` where test_name targets the specific tool. Then run the full suite at the end.

**What NOT to convert:**

- `data()` tool — polymorphic response (get/set/delete produce different shapes). Keeps returning `dict[str, Any]`.
- `data_schema()` tool — polymorphic response (validate/scan/add_dir/etc. produce different shapes). Keeps returning `dict[str, Any]`.
- These will use typed internal handlers in a future refinement, but the tool-level return type stays dict.
  </action>
  <verify>
  uv run python -c "
  from mcp_json_yaml_toml import server
  tools = server.mcp.\_tool_manager.\_tools
  for name in ['data_query', 'data_convert', 'data_merge', 'constraint_validate', 'constraint_list']:
  tool = tools[name]
  schema = tool.output_schema if hasattr(tool, 'output_schema') else None
  print(f'{name}: output_schema={schema is not None}')
  "
  uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q
  uv run ruff check packages/mcp_json_yaml_toml/tools/ packages/mcp_json_yaml_toml/services/data_operations.py
  uv run mypy packages/ --show-error-codes
  uv run basedpyright packages/
  </verify>
  <done>
  data_query, data_convert, data_merge, constraint_validate, constraint_list all return
  Pydantic response models. FastMCP generates output_schema for each.
  data and data_schema remain dict returns (polymorphic).
  All 395 tests pass. Ruff, mypy, basedpyright clean.
  </done>
  </task>

</tasks>

<verification>
- `uv run pytest packages/mcp_json_yaml_toml/tests/ -q` — all tests pass
- `uv run ruff check packages/mcp_json_yaml_toml/` — clean
- `uv run mypy packages/ --show-error-codes` — no new errors
- `uv run basedpyright packages/` — no new errors
- All 7 tools have complete annotations (4 hints each)
- 5 tools (data_query, data_convert, data_merge, constraint_validate, constraint_list) return Pydantic models
- 2 tools (data, data_schema) return dict[str, Any] (polymorphic — by design)
- FastMCP generates output_schema for tools returning Pydantic models
</verification>

<success_criteria>

- FMCP-04 complete: All tool return types use Pydantic response models (or dict with typed internals for polymorphic tools)
- FMCP-05 complete: All tools have readOnlyHint, destructiveHint, idempotentHint, openWorldHint annotations
- All 395 tests pass without modification
- Type checkers (mypy, basedpyright) pass clean
  </success_criteria>

<output>
After completion, create `.planning/phases/02-tool-layer-refactoring/02-04-SUMMARY.md`
</output>
