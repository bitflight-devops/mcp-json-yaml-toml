---
phase: 04-competitive-features
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - pyproject.toml
  - packages/mcp_json_yaml_toml/telemetry.py
  - packages/mcp_json_yaml_toml/backends/yq.py
  - packages/mcp_json_yaml_toml/tests/test_telemetry.py
autonomous: true

must_haves:
  truths:
    - "OpenTelemetry SDK packages are installable via optional extras: pip install mcp-json-yaml-toml[telemetry]"
    - "Custom spans are emitted around yq subprocess execution when OTEL SDK is configured"
    - "No overhead when OTEL SDK is not installed (get_tracer returns no-op tracer)"
    - "Server starts and operates normally without OTEL SDK installed"
  artifacts:
    - path: "pyproject.toml"
      provides: "Optional telemetry dependency group"
      contains: "[project.optional-dependencies]"
    - path: "packages/mcp_json_yaml_toml/telemetry.py"
      provides: "Telemetry helper with get_tracer and traced_yq_execute"
      contains: "def get_tracer"
    - path: "packages/mcp_json_yaml_toml/tests/test_telemetry.py"
      provides: "Tests verifying custom span emission and no-op behavior"
      min_lines: 40
  key_links:
    - from: "packages/mcp_json_yaml_toml/backends/yq.py"
      to: "packages/mcp_json_yaml_toml/telemetry.py"
      via: "import tracer for span creation"
      pattern: "from mcp_json_yaml_toml\\.telemetry import"
    - from: "pyproject.toml"
      to: "opentelemetry-sdk"
      via: "optional dependency declaration"
      pattern: "opentelemetry-sdk"
---

<objective>
Add OpenTelemetry observability with optional SDK extras and custom spans for yq subprocess visibility.

Purpose: FEAT-02 -- Users monitoring MCP server performance need trace data. FastMCP 3.x provides automatic instrumentation for all tool calls. This plan adds: (1) optional SDK dependency extras for easy installation, (2) custom spans around yq subprocess execution for fine-grained timing visibility, and (3) a telemetry helper module.

Output: Optional `[telemetry]` extras in pyproject.toml, telemetry.py helper module, custom spans in yq backend, and integration tests.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-competitive-features/04-RESEARCH.md

Key patterns to follow:

- FastMCP telemetry: <https://gofastmcp.com/servers/telemetry> -- get_tracer() returns no-op when no SDK configured
- Custom spans: tracer.start_as_current_span("yq.execute") with attributes for expression, format, returncode
- OTEL SDK must NOT be a required dependency -- optional extras only
- opentelemetry-api is already a transitive dep of FastMCP, always available
- Backend file: See backends/yq.py for execute_yq function where custom spans should wrap subprocess calls
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Add optional OTEL extras and create telemetry helper module</name>
  <files>
    pyproject.toml
    packages/mcp_json_yaml_toml/telemetry.py
  </files>
  <action>
1. Add optional dependency group to pyproject.toml. Use `uv add` for each, then move from dependencies to optional-dependencies manually if uv doesn't support optional extras directly. The target pyproject.toml structure:
   ```toml
   [project.optional-dependencies]
   telemetry = [
       "opentelemetry-sdk>=1.30.0",
       "opentelemetry-exporter-otlp-proto-grpc>=1.30.0",
   ]
   ```
   NOTE: Do NOT add these as main dependencies. They are optional extras.
   The `opentelemetry-api` package is already a transitive dependency of FastMCP and does not need to be declared.

For testing purposes, add opentelemetry-sdk to the dev dependency group:

```bash
uv add --dev "opentelemetry-sdk>=1.30.0"
```

2. Create packages/mcp_json_yaml_toml/telemetry.py:

   ```python
   """OpenTelemetry helpers for MCP JSON/YAML/TOML server.

   Provides a tracer instance and span utilities for yq subprocess visibility.
   Uses FastMCP's built-in telemetry when available, falls back to opentelemetry-api
   (always available as FastMCP transitive dep). Returns no-op tracer when no SDK configured.
   """
   from __future__ import annotations

   from typing import TYPE_CHECKING, Any

   from opentelemetry import trace

   if TYPE_CHECKING:
       from opentelemetry.trace import Tracer

   # Module-level tracer -- no-op when SDK not configured
   _TRACER_NAME = "mcp-json-yaml-toml"


   def get_tracer() -> Tracer:
       """Get the package tracer.

       Returns a no-op tracer when no OTEL SDK is configured,
       so there is zero overhead for users without telemetry.
       """
       return trace.get_tracer(_TRACER_NAME)
   ```

   Add **all** with "get_tracer".
   </action>
   <verify>

```bash
uv run python -c "from mcp_json_yaml_toml.telemetry import get_tracer; t = get_tracer(); print(type(t))"
uv run prek run --files packages/mcp_json_yaml_toml/telemetry.py
```

Verify pyproject.toml has [project.optional-dependencies] section with telemetry group.
</verify>
<done>telemetry.py provides get_tracer(), optional-dependencies declared in pyproject.toml, dev group has opentelemetry-sdk for testing</done>
</task>

<task type="auto">
  <name>Task 2: Add custom spans to yq backend and create telemetry tests</name>
  <files>
    packages/mcp_json_yaml_toml/backends/yq.py
    packages/mcp_json_yaml_toml/tests/test_telemetry.py
  </files>
  <action>
1. Modify backends/yq.py to add custom span around the subprocess call in execute_yq:
   - Import get_tracer from telemetry module: `from mcp_json_yaml_toml.telemetry import get_tracer`
   - Inside the execute_yq function, wrap the subprocess.run call with a span:
     ```python
     tracer = get_tracer()
     with tracer.start_as_current_span("yq.execute") as span:
         span.set_attribute("yq.expression", expression)
         if input_format:
             span.set_attribute("yq.input_format", str(input_format))
         if output_format:
             span.set_attribute("yq.output_format", str(output_format))
         # ... existing subprocess.run call ...
         span.set_attribute("yq.returncode", result.returncode)
     ```
   - The span should wrap ONLY the subprocess.run call and the result processing, not the argument building.
   - Do NOT change the function signature or return type.

2. Create tests/test_telemetry.py:
   - Test get_tracer returns a tracer object (even without SDK, it's a no-op tracer)
   - Test with InMemorySpanExporter (SDK is in dev deps):
     a. Configure TracerProvider with SimpleSpanProcessor + InMemorySpanExporter
     b. Set as global tracer provider
     c. Call get_tracer() and create a manual span
     d. Verify span appears in exporter.get_finished_spans()
     e. Restore original tracer provider in cleanup
   - Test execute_yq emits "yq.execute" span:
     a. Configure InMemorySpanExporter as above
     b. Create a simple JSON file via tmp_path
     c. Call execute_yq with a simple expression (e.g., "." on the JSON file)
     d. Verify a span named "yq.execute" exists in exported spans
     e. Verify span attributes include yq.expression, yq.input_format, yq.returncode
   - Use pytest fixtures for tracer provider setup/teardown:

     ```python
     @pytest.fixture
     def trace_exporter():
         from opentelemetry.sdk.trace import TracerProvider
         from opentelemetry.sdk.trace.export import SimpleSpanProcessor
         from opentelemetry.sdk.trace.export.in_memory_span_exporter import InMemorySpanExporter

         exporter = InMemorySpanExporter()
         provider = TracerProvider()
         provider.add_span_processor(SimpleSpanProcessor(exporter))
         original = trace.get_tracer_provider()
         trace.set_tracer_provider(provider)
         yield exporter
         exporter.clear()
         trace.set_tracer_provider(original)
     ```

     </action>
     <verify>

```bash
uv run pytest packages/mcp_json_yaml_toml/tests/test_telemetry.py -v
uv run pytest -x  # Full suite
uv run prek run --files packages/mcp_json_yaml_toml/backends/yq.py packages/mcp_json_yaml_toml/tests/test_telemetry.py
```

  </verify>
  <done>Custom "yq.execute" spans emitted during execute_yq calls, span attributes include expression/format/returncode, all tests pass, full suite passes</done>
</task>

</tasks>

<verification>
1. `uv run pytest packages/mcp_json_yaml_toml/tests/test_telemetry.py -v` -- telemetry tests pass
2. `uv run pytest -x` -- full test suite passes (no regressions from yq.py changes)
3. `uv run prek run --files packages/mcp_json_yaml_toml/telemetry.py packages/mcp_json_yaml_toml/backends/yq.py` -- all quality gates pass
4. `uv run python -c "from mcp_json_yaml_toml.telemetry import get_tracer; print(get_tracer())"` -- tracer importable and functional
5. Verify pyproject.toml contains `[project.optional-dependencies]` telemetry group
</verification>

<success_criteria>

- Optional telemetry extras declared in pyproject.toml (opentelemetry-sdk, opentelemetry-exporter-otlp-proto-grpc)
- get_tracer() returns working tracer (no-op when no SDK configured)
- execute_yq emits "yq.execute" span with expression, format, and returncode attributes
- Server starts normally without OTEL SDK (no import errors, no performance impact)
- All existing tests pass without modification
- All linting gates pass (ruff, mypy, basedpyright)
  </success_criteria>

<output>
After completion, create `.planning/phases/04-competitive-features/04-02-SUMMARY.md`
</output>
