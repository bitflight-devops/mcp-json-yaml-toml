---
phase: 06-operational-safety
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp_json_yaml_toml/config.py
  - packages/mcp_json_yaml_toml/yaml_optimizer.py
  - packages/mcp_json_yaml_toml/schemas.py
  - packages/mcp_json_yaml_toml/tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "config.py caches parsed environment configuration and does not re-parse on every call"
    - "yaml_optimizer.py validates environment input instead of crashing at import time"
    - "logging.debug() uses lazy %-formatting in all 3 sites in schemas.py"
  artifacts:
    - path: "packages/mcp_json_yaml_toml/config.py"
      provides: "Cached environment configuration"
      contains: "functools.lru_cache"
    - path: "packages/mcp_json_yaml_toml/yaml_optimizer.py"
      provides: "Safe environment config parsing"
      contains: "except (ValueError, TypeError)"
    - path: "packages/mcp_json_yaml_toml/schemas.py"
      provides: "Lazy %-formatted logging"
      contains: 'logging.debug("'
  key_links:
    - from: "packages/mcp_json_yaml_toml/tests/conftest.py"
      to: "packages/mcp_json_yaml_toml/config.py"
      via: "cache_clear in clean_environment fixture"
      pattern: "parse_enabled_formats\\.cache_clear"
---

<objective>
Add configuration caching to config.py, validate environment input in yaml_optimizer.py, and fix lazy %-formatting in schemas.py logging calls.

Purpose: Eliminate repeated environment variable parsing (OPS-02), prevent import-time crashes from invalid env values (OPS-03), and avoid unnecessary f-string evaluation in disabled debug logging (OPS-04).
Output: Cached config, safe env parsing, lazy-formatted logging.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@packages/mcp_json_yaml_toml/config.py
@packages/mcp_json_yaml_toml/yaml_optimizer.py
@packages/mcp_json_yaml_toml/schemas.py
@packages/mcp_json_yaml_toml/tests/conftest.py
@packages/mcp_json_yaml_toml/tests/test_config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add configuration caching and safe environment parsing</name>
  <files>
packages/mcp_json_yaml_toml/config.py
packages/mcp_json_yaml_toml/yaml_optimizer.py
packages/mcp_json_yaml_toml/tests/conftest.py
  </files>
  <action>
**OPS-02: Cache parsed environment configuration in config.py**

1. Add `import functools` to imports in config.py.
2. Decorate `parse_enabled_formats()` with `@functools.lru_cache(maxsize=1)`. Using `lru_cache` (not `cache`) because `lru_cache` provides `.cache_clear()` which tests need to reset state between runs.
3. The function reads `os.environ.get("MCP_CONFIG_FORMATS")` — the return value is a list, which is unhashable. `lru_cache` on a no-argument function works because there are no arguments to hash. However, the return value is a list which is mutable. Callers could mutate the cached list. Change the return type annotation to `tuple[FormatType, ...]` and return `tuple(...)` instead of `list(...)` at each return site. This makes the cached value immutable.
   - `return list(DEFAULT_FORMATS)` -> `return tuple(DEFAULT_FORMATS)`
   - `return list(DEFAULT_FORMATS)` (fallback) -> `return tuple(DEFAULT_FORMATS)`
   - `return enabled_formats` -> `return tuple(enabled_formats)` (the local `enabled_formats` is built as a list, convert at return)
   - Update type annotation: `def parse_enabled_formats() -> tuple[FormatType, ...]:`
4. Update callers within config.py that depended on list return type — check `require_format_enabled()`, `is_format_enabled()`, `get_enabled_formats_str()`. These iterate over the result, which works identically for tuples as lists. No changes needed.
5. Update `DEFAULT_FORMATS` type annotation from `list[FormatType]` to `tuple[FormatType, ...]` and change the value from `[...]` to `(...)` for consistency. Update `__all__` if needed.

**Test fixture update:**

6. In `packages/mcp_json_yaml_toml/tests/conftest.py`, update the `clean_environment` fixture to clear the cache after modifying the environment:
   ```python
   @pytest.fixture
   def clean_environment(monkeypatch: pytest.MonkeyPatch) -> None:
       monkeypatch.delenv("MCP_CONFIG_FORMATS", raising=False)
       from mcp_json_yaml_toml.config import parse_enabled_formats
       parse_enabled_formats.cache_clear()
   ```
7. Also check `json_only_environment` fixture and any other fixtures that set `MCP_CONFIG_FORMATS` — add `parse_enabled_formats.cache_clear()` after setting the env var.
8. For tests that use `monkeypatch.setenv("MCP_CONFIG_FORMATS", ...)` directly (not via fixture), the cache must also be cleared. The cleanest approach: add an `autouse=True` fixture at the conftest level that clears the cache before every test, OR update the `clean_environment` fixture to use a finalizer. The simplest correct approach: create an autouse session-scoped or function-scoped fixture that always clears the parse cache:

   ```python
   @pytest.fixture(autouse=True)
   def _clear_config_cache() -> Generator[None, None, None]:
       """Clear config cache before and after each test for isolation."""
       from mcp_json_yaml_toml.config import parse_enabled_formats
       parse_enabled_formats.cache_clear()
       yield
       parse_enabled_formats.cache_clear()
   ```

   Place this near the `clean_environment` fixture. This ensures every test starts and ends with a clean cache regardless of whether they use `clean_environment` or `monkeypatch.setenv` directly.

9. Update `test_config.py` assertions that check `result == list(DEFAULT_FORMATS)` — since `parse_enabled_formats()` now returns a tuple and `DEFAULT_FORMATS` is a tuple, update assertions to compare directly: `result == DEFAULT_FORMATS` (both tuples). Also update `len(result) == 3` assertions — tuples have len(), no change needed there. Check `FormatType.JSON in result` assertions — `in` works on tuples, no change needed.

**OPS-03: Validate yaml_optimizer.py environment config**

10. In yaml_optimizer.py, replace the bare `int(os.getenv(...))` calls (lines 19-23) with validated parsing:

        ```python
        def _parse_env_int(name: str, default: int) -> int:
            """Parse an integer from environment variable with fallback."""
            raw = os.getenv(name, "")
            if not raw:
                return default
            try:
                return int(raw)
            except (ValueError, TypeError):
                return default


        def _parse_env_bool(name: str, default: bool) -> bool:
            """Parse a boolean from environment variable with fallback."""
            raw = os.getenv(name, "")
            if not raw:
                return default
            return raw.strip().lower() == "true"


        YAML_ANCHOR_MIN_SIZE = _parse_env_int("YAML_ANCHOR_MIN_SIZE", 3)
        YAML_ANCHOR_MIN_DUPLICATES = _parse_env_int("YAML_ANCHOR_MIN_DUPLICATES", 2)
        YAML_ANCHOR_OPTIMIZATION = _parse_env_bool("YAML_ANCHOR_OPTIMIZATION", True)
        ```

        This prevents `ValueError` at import time if someone sets `YAML_ANCHOR_MIN_SIZE=abc`.

      </action>
      <verify>
    Run: `uv run prek run --files packages/mcp_json_yaml_toml/config.py packages/mcp_json_yaml_toml/yaml_optimizer.py packages/mcp_json_yaml_toml/tests/conftest.py`

Additionally verify:

- `uv run pytest packages/mcp_json_yaml_toml/tests/test_config.py -x -q` passes
- `uv run pytest packages/mcp_json_yaml_toml/tests/test_yaml_optimizer.py -x -q` passes
- `uv run python -c "from mcp_json_yaml_toml.config import parse_enabled_formats; print(hasattr(parse_enabled_formats, 'cache_clear'))"` returns True
- `uv run python -c "import os; os.environ['YAML_ANCHOR_MIN_SIZE']='abc'; from mcp_json_yaml_toml.yaml_optimizer import YAML_ANCHOR_MIN_SIZE; print(YAML_ANCHOR_MIN_SIZE)"` returns 3 (default)
  </verify>
  <done>
  parse_enabled_formats() is cached with lru_cache. yaml_optimizer.py validates environment input with fallback defaults. All tests pass with cache cleared between runs.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Fix lazy %-formatting in schemas.py logging calls</name>
  <files>packages/mcp_json_yaml_toml/schemas.py</files>
  <action>
**OPS-04: Fix 3 f-string logging.debug() calls in schemas.py**

Replace f-strings with lazy %-formatting in these 3 locations:

1. Line 290: `logging.debug(f"Failed to load default IDE patterns: {e}")`
   -> `logging.debug("Failed to load default IDE patterns: %s", e)`

2. Line 672: `logging.debug(f"Failed to load schema config: {e}")`
   -> `logging.debug("Failed to load schema config: %s", e)`

3. Line 695: `logging.debug(f"Failed to parse catalog as SchemaCatalog: {e}")`
   -> `logging.debug("Failed to parse catalog as SchemaCatalog: %s", e)`

This ensures the string formatting is only performed when debug logging is actually enabled, avoiding unnecessary string construction overhead.
</action>
<verify>
Run: `uv run prek run --files packages/mcp_json_yaml_toml/schemas.py`

Additionally verify:

- `grep 'logging.debug(f"' packages/mcp_json_yaml_toml/schemas.py` returns no matches
- `grep -c 'logging.debug("' packages/mcp_json_yaml_toml/schemas.py` returns 3
- `uv run pytest packages/mcp_json_yaml_toml/tests/test_schema_detection.py -x -q` passes
  </verify>
  <done>
  All 3 logging.debug() calls in schemas.py use lazy %-formatting instead of f-strings. No f-string logging calls remain.
  </done>
  </task>

</tasks>

<verification>
1. `uv run python -c "from mcp_json_yaml_toml.config import parse_enabled_formats; print(type(parse_enabled_formats()))"` shows tuple
2. `uv run python -c "from mcp_json_yaml_toml.config import parse_enabled_formats; print(hasattr(parse_enabled_formats, 'cache_clear'))"` shows True
3. `grep 'logging.debug(f"' packages/mcp_json_yaml_toml/schemas.py` returns no matches
4. `uv run prek run --files packages/mcp_json_yaml_toml/config.py packages/mcp_json_yaml_toml/yaml_optimizer.py packages/mcp_json_yaml_toml/schemas.py packages/mcp_json_yaml_toml/tests/conftest.py` passes all gates
5. `uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q` passes
</verification>

<success_criteria>

- parse_enabled_formats() is decorated with lru_cache and returns immutable tuple
- yaml_optimizer.py safely handles invalid environment variable values (no crash on import)
- All logging.debug() calls in schemas.py use lazy %-formatting
- All tests pass with proper cache isolation between test runs
- All quality gates pass
  </success_criteria>

<output>
After completion, create `.planning/phases/06-operational-safety/06-02-SUMMARY.md`
</output>
