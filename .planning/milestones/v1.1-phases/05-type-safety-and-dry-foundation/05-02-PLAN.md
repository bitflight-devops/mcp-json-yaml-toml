---
phase: 05-type-safety-and-dry-foundation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - packages/mcp_json_yaml_toml/services/data_operations.py
  - packages/mcp_json_yaml_toml/formats/base.py
  - packages/mcp_json_yaml_toml/tools/data.py
autonomous: true

must_haves:
  truths:
    - "All service handler functions return typed Pydantic models, not dict[str, Any]"
    - "Format type checks use FormatType enum consistently with no mixed string/enum comparisons"
    - "Exception handling uses specific exception types, not broad except Exception with isinstance guards"
  artifacts:
    - path: "packages/mcp_json_yaml_toml/services/data_operations.py"
      provides: "All handler and dispatcher functions returning DataResponse or MutationResponse"
      contains: "-> DataResponse"
    - path: "packages/mcp_json_yaml_toml/services/data_operations.py"
      provides: "Specific exception catches replacing broad except Exception"
      contains: "except (KeyError, TypeError, ValueError)"
    - path: "packages/mcp_json_yaml_toml/formats/base.py"
      provides: "FormatType enum comparison using match statement"
      contains: "case FormatType.JSON"
  key_links:
    - from: "packages/mcp_json_yaml_toml/services/data_operations.py"
      to: "packages/mcp_json_yaml_toml/models/responses.py"
      via: "DataResponse and MutationResponse imports and constructors"
      pattern: "return (DataResponse|MutationResponse)\\("
    - from: "packages/mcp_json_yaml_toml/tools/data.py"
      to: "packages/mcp_json_yaml_toml/services/data_operations.py"
      via: "Dispatcher returns flow through to tool return type"
      pattern: "_dispatch_(get|set|delete)_operation"
---

<objective>
Migrate all service handler functions from dict[str, Any] returns to typed Pydantic models, fix mixed string/enum format comparisons, and replace broad exception catches with specific types.

Purpose: Satisfy TYPE-01 (Pydantic returns), TYPE-02 (FormatType enum consistency), and TYPE-03 (specific exception handling). Establishes compile-time type safety across the entire CRUD service layer.
Output: All 13 dict-returning functions in data_operations.py return DataResponse or MutationResponse. Mixed format checks in base.py use match/case on FormatType. Broad except Exception blocks replaced with specific catches.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-type-safety-and-dry-foundation/05-01-SUMMARY.md
@.claude/smells/core-modules.smells.20260215-104520.md
@.claude/smells/codebase.smells.20260215-104521.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate data_operations.py handlers to Pydantic return types and fix exception handling</name>
  <files>
    packages/mcp_json_yaml_toml/services/data_operations.py
    packages/mcp_json_yaml_toml/tools/data.py
  </files>
  <action>
**TYPE-01: Replace dict[str, Any] returns with Pydantic models**

Import `MutationResponse` from `models.responses` (already imports `DataResponse` and `SchemaResponse`).

Migrate each function:

**`_handle_data_get_structure` (returns dict -> DataResponse):**
Change return type from `dict[str, Any]` to `DataResponse`. Replace all `response = {...}` dict constructions with `DataResponse(...)` constructor calls. There are three return paths:

1. Null data: `DataResponse(success=True, result=None, format="json", file=str(path), structure_summary="Empty or invalid data", schema_info=schema_info)`
2. Paginated: `DataResponse(success=True, result=pagination["data"], format="json", file=str(path), paginated=True, nextCursor=pagination.get("nextCursor"))`
3. Normal: `DataResponse(success=True, result=summary, format="json", file=str(path), schema_info=schema_info)`

**`_handle_data_get_value` (returns dict -> DataResponse):**
Change return type from `dict[str, Any]` to `DataResponse`. Two return paths:

1. Paginated: `DataResponse(success=True, result=pagination["data"], format=output_fmt, file=str(path), paginated=True, nextCursor=pagination.get("nextCursor"), advisory=pagination.get("advisory"))`
2. Normal: `DataResponse(success=True, result=result_str if output_fmt != "json" else result.data, format=output_fmt, file=str(path), schema_info=schema_info)`

**`_set_toml_value_handler` (returns dict -> MutationResponse):**
Change return type to `MutationResponse`. Single return:
`MutationResponse(success=True, result="File modified successfully", file=str(path), schema_info=schema_info)`

**`_handle_data_set` (returns dict -> MutationResponse):**
Change return type to `MutationResponse`. Single return path (after the TOML branch which delegates to `_set_toml_value_handler`):
`MutationResponse(success=True, result="File modified successfully", file=str(path), optimized=optimized, message="File modified and optimized with YAML anchors" if optimized else None, schema_info=schema_info)`

**`_delete_toml_key_handler` (returns dict -> MutationResponse):**
Change return type to `MutationResponse`:
`MutationResponse(success=True, result="File modified successfully", file=str(path), schema_info=schema_info)`

**`_delete_yq_key_handler` (returns dict -> MutationResponse):**
Change return type to `MutationResponse`:
`MutationResponse(success=True, result="File modified successfully", file=str(path), schema_info=schema_info)`

**`_handle_data_delete` (returns dict -> MutationResponse):**
Change return type to `MutationResponse`. This function delegates to `_delete_toml_key_handler` or `_delete_yq_key_handler`, both now returning `MutationResponse`.

**Dispatcher functions: `_dispatch_get_operation`, `_dispatch_set_operation`, `_dispatch_delete_operation`:**
Change return types from `dict[str, Any]` to `DataResponse | SchemaResponse`, `MutationResponse`, and `MutationResponse` respectively.

The `_dispatch_get_operation` has a special case: when `data_type == "schema"`, it currently calls `_handle_data_get_schema(path, schema_manager).model_dump(exclude_none=True, by_alias=True)` to convert the SchemaResponse back to a dict. Since the dispatcher should now return typed models, change this to return the SchemaResponse directly: `return _handle_data_get_schema(path, schema_manager)`. The return type becomes `DataResponse | SchemaResponse`.

**Update `tools/data.py`:**
The `data` tool function receives the return from dispatchers. Currently its return type annotation uses `dict[str, Any]` (check actual annotation). Since dispatchers now return different model types, and the `data` tool already returns `dict[str, Any]` which FastMCP serializes, we need to update:

- Change the tool function's return type. The dispatchers return `DataResponse | SchemaResponse | MutationResponse`. Since FastMCP handles Pydantic models as return values, and the data tool needs a single output_schema, keep the return as the union type. If this causes type checker issues, use the common base `ToolResponse` as return type.
- Remove the `.model_dump()` call on the schema branch in `_dispatch_get_operation`.

**TYPE-03: Replace broad exception catches with specific types**

In `_set_toml_value_handler`, replace:

```python
except Exception as e:
    if isinstance(e, ToolError):
        raise
    raise ToolError(f"TOML set operation failed: {e}") from e
```

with:

```python
except (KeyError, TypeError, ValueError, OSError) as e:
    raise ToolError(f"TOML set operation failed: {e}") from e
```

In `_handle_data_set`, replace the broad except block (lines 419-422):

```python
except Exception as e:
    if isinstance(e, ToolError):
        raise
    raise ToolError(f"Set operation failed: {e}") from e
```

with:

```python
except (TypeError, ValueError, OSError) as e:
    raise ToolError(f"Set operation failed: {e}") from e
```

Note: ToolError from `_validate_and_write_content` propagates naturally since it is not caught. `YQExecutionError` is already caught separately above.

In `_delete_toml_key_handler` (lines 466-469):

```python
except ToolError:
    raise
except Exception as e:
    raise ToolError(f"TOML delete operation failed: {e}") from e
```

Replace with:

```python
except (TypeError, ValueError, OSError) as e:
    raise ToolError(f"TOML delete operation failed: {e}") from e
```

Note: `KeyError` is already caught separately above at line 464. `ToolError` propagates naturally.

In `_delete_yq_key_handler` (lines 518-521):

```python
except ToolError:
    raise
except Exception as e:
    raise ToolError(f"Delete operation failed: {e}") from e
```

Replace with:

```python
except (TypeError, ValueError, OSError) as e:
    raise ToolError(f"Delete operation failed: {e}") from e
```

Note: `YQExecutionError` is already caught at line 516.
</action>
<verify>
Run `uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q` -- all tests must pass. The `_DictAccessMixin` on response models ensures existing test assertions using `result["key"]` patterns continue to work.

Run `uv run prek run --files packages/mcp_json_yaml_toml/services/data_operations.py packages/mcp_json_yaml_toml/tools/data.py` -- linting and type checking pass.

Verify: Search for `-> dict[str, Any]` in `services/data_operations.py` -- should find zero occurrences (only TYPE_CHECKING imports of dict remain).
</verify>
<done>All 13 handler/dispatcher functions in data_operations.py return typed Pydantic models (DataResponse, MutationResponse, SchemaResponse). All 4 broad `except Exception` blocks replaced with specific exception types. Tests pass via \_DictAccessMixin backward compatibility.</done>
</task>

<task type="auto">
  <name>Task 2: Fix FormatType enum consistency in format comparisons</name>
  <files>
    packages/mcp_json_yaml_toml/formats/base.py
  </files>
  <action>
**TYPE-02: Fix mixed string/enum comparison in `_parse_content_for_validation`**

The function at `formats/base.py:48-73` uses inconsistent comparisons:

```python
if input_format == "json":              # string only
if input_format in {"yaml", FormatType.YAML}:  # both
if input_format in {"toml", FormatType.TOML}:  # both
```

Since `FormatType` is a `StrEnum`, comparing against string values works correctly. However, the inconsistency is a maintenance hazard. Normalize the input and use match/case:

```python
def _parse_content_for_validation(
    content: str, input_format: FormatType | str
) -> Any | None:
    """Parse content string into data structure for schema validation.

    Args:
        content: Raw file content string
        input_format: File format (json, yaml, toml)

    Returns:
        Parsed data structure or None if format not recognized

    Raises:
        ToolError: If parsing fails
    """
    # Normalize to FormatType for consistent comparison
    try:
        fmt = FormatType(input_format) if not isinstance(input_format, FormatType) else input_format
    except ValueError:
        return None

    try:
        match fmt:
            case FormatType.JSON:
                return orjson.loads(content)
            case FormatType.YAML:
                yaml = YAML(typ="safe", pure=True)
                return yaml.load(content)
            case FormatType.TOML:
                return tomlkit.parse(content)
            case _:
                return None
    except Exception as e:
        raise ToolError(f"Failed to parse content for validation: {e}") from e
```

This eliminates all mixed string/enum comparisons. The `except Exception` here is acceptable since it wraps three different parsing libraries (orjson, ruamel.yaml, tomlkit) each with their own exception types, and the intent is to give a uniform "parse failed" message.

Also check for any other mixed string/enum format comparisons in `data_operations.py`:

- Line 237: `if output_fmt != "json"` -- this works because FormatType is StrEnum, but for consistency change to `if output_fmt != FormatType.JSON`
- Line 263: same pattern
- Line 392: `if input_format == "toml"` -- change to `if input_format == FormatType.TOML`
- Line 425: `if input_format == "yaml"` -- change to `if input_format == FormatType.YAML`
- Line 559: `if input_format == "toml"` -- change to `if input_format == FormatType.TOML`
- Line 733: `if output_format != "json"` -- change to `if output_format != FormatType.JSON`

These are all working correctly due to StrEnum, but normalizing them to enum comparisons satisfies TYPE-02 and prevents future breakage.
</action>
<verify>
Run `uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q` -- all tests pass.

Run `uv run prek run --files packages/mcp_json_yaml_toml/formats/base.py packages/mcp_json_yaml_toml/services/data_operations.py` -- all gates pass.

Verify: Search for `== "json"` and `== "yaml"` and `== "toml"` in `formats/base.py` and `services/data_operations.py` -- should find zero occurrences (all comparisons use FormatType enum).
</verify>
<done>All format comparisons in formats/base.py and services/data_operations.py use FormatType enum values consistently. No mixed string/enum comparisons remain. `_parse_content_for_validation` uses match/case on normalized FormatType.</done>
</task>

</tasks>

<verification>
1. `uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q` -- full test suite passes
2. `uv run prek run --files packages/mcp_json_yaml_toml/services/data_operations.py packages/mcp_json_yaml_toml/formats/base.py packages/mcp_json_yaml_toml/tools/data.py` -- all gates pass
3. Search for `-> dict[str, Any]` in `services/data_operations.py` returns 0 matches for function return types
4. Search for `except Exception as e:` in `services/data_operations.py` returns 0 matches (only specific catches remain)
5. Search for `== "json"`, `== "yaml"`, `== "toml"` in `formats/base.py` and `services/data_operations.py` returns 0 matches
</verification>

<success_criteria>

- TYPE-01 complete: All handler functions return DataResponse, MutationResponse, or SchemaResponse
- TYPE-02 complete: All format comparisons use FormatType enum, no mixed string/enum checks
- TYPE-03 complete: All exception handlers catch specific types, no broad except Exception with isinstance guards
- Zero test regressions (backward compat via \_DictAccessMixin)
- All lint and type check gates pass
  </success_criteria>

<output>
After completion, create `.planning/phases/05-type-safety-and-dry-foundation/05-02-SUMMARY.md`
</output>
