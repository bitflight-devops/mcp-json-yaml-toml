---
phase: 05-type-safety-and-dry-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - packages/mcp_json_yaml_toml/config.py
  - packages/mcp_json_yaml_toml/toml_utils.py
  - packages/mcp_json_yaml_toml/tools/data.py
  - packages/mcp_json_yaml_toml/tools/query.py
  - packages/mcp_json_yaml_toml/tools/convert.py
  - packages/mcp_json_yaml_toml/tools/diff.py
  - packages/mcp_json_yaml_toml/tools/schema.py
  - packages/mcp_json_yaml_toml/services/data_operations.py
  - packages/mcp_json_yaml_toml/formats/base.py
autonomous: true

must_haves:
  truths:
    - "Format-enable checks execute through a single shared function across all 9 call sites"
    - "File path resolution uses a shared utility in all tool modules"
    - "TOML key-path navigation is extracted to a single shared function used by both set and delete"
    - "TOML-to-JSON fallback logic exists in one location, called from both data_operations and query"
  artifacts:
    - path: "packages/mcp_json_yaml_toml/config.py"
      provides: "require_format_enabled() function"
      contains: "def require_format_enabled"
    - path: "packages/mcp_json_yaml_toml/formats/base.py"
      provides: "resolve_file_path() shared utility and should_fallback_toml_to_json() helper"
      contains: "def resolve_file_path"
    - path: "packages/mcp_json_yaml_toml/toml_utils.py"
      provides: "_navigate_to_parent() shared navigation function"
      contains: "def _navigate_to_parent"
  key_links:
    - from: "packages/mcp_json_yaml_toml/tools/*.py"
      to: "packages/mcp_json_yaml_toml/config.py"
      via: "require_format_enabled import"
      pattern: "from mcp_json_yaml_toml\\.config import.*require_format_enabled"
    - from: "packages/mcp_json_yaml_toml/tools/*.py"
      to: "packages/mcp_json_yaml_toml/formats/base.py"
      via: "resolve_file_path import"
      pattern: "from mcp_json_yaml_toml\\.formats\\.base import.*resolve_file_path"
    - from: "packages/mcp_json_yaml_toml/toml_utils.py"
      to: "packages/mcp_json_yaml_toml/toml_utils.py"
      via: "_navigate_to_parent called by set_toml_value and delete_toml_key"
      pattern: "_navigate_to_parent\\("
---

<objective>
Extract duplicated patterns into shared utility functions to eliminate DRY violations across the codebase.

Purpose: Satisfy DRY-01 (format-enable check), DRY-02 (TOML fallback), and DRY-03 (file path resolution, TOML key navigation). These shared utilities are prerequisites for the type safety work in Plan 02.
Output: Four new shared functions; 9 format-check sites, 10+ path resolution sites, 2 TOML fallback sites, and 2 TOML navigation sites all refactored to use them.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.claude/smells/core-modules.smells.20260215-104520.md
@.claude/smells/codebase.smells.20260215-104521.md
@.claude/smells/architecture-tools.smells.20260215-104520.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract DRY utility functions</name>
  <files>
    packages/mcp_json_yaml_toml/config.py
    packages/mcp_json_yaml_toml/formats/base.py
    packages/mcp_json_yaml_toml/toml_utils.py
  </files>
  <action>
**DRY-01: `require_format_enabled()` in config.py**

Add a new function to `config.py`:

```python
def require_format_enabled(format_type: FormatType) -> None:
    """Raise ToolError if the given format is not enabled.

    Args:
        format_type: The format to check (FormatType enum or string).

    Raises:
        ToolError: If format is disabled, with message listing enabled formats.
    """
    if not is_format_enabled(format_type):
        enabled = parse_enabled_formats()
        raise ToolError(
            f"Format '{format_type}' is not enabled. "
            f"Enabled formats: {', '.join(f.value for f in enabled)}"
        )
```

This requires importing `ToolError` from `fastmcp.exceptions`. Add `require_format_enabled` to the module's exports (add `__all__` if missing).

**DRY-03a: `resolve_file_path()` in formats/base.py**

Add a new function to `formats/base.py`:

```python
def resolve_file_path(file_path: str, *, must_exist: bool = True) -> Path:
    """Resolve and validate a file path.

    Args:
        file_path: Raw file path string from tool input.
        must_exist: If True (default), raise ToolError when file does not exist.

    Returns:
        Resolved absolute Path.

    Raises:
        ToolError: If must_exist is True and file does not exist.
    """
    path = Path(file_path).expanduser().resolve()
    if must_exist and not path.exists():
        raise ToolError(f"File not found: {file_path}")
    return path
```

Add to `__all__` in `formats/base.py`.

**DRY-02: `should_fallback_toml_to_json()` in formats/base.py**

Add a helper function:

```python
def should_fallback_toml_to_json(
    error: YQExecutionError,
    output_format_explicit: bool,
    output_format: FormatType,
    input_format: FormatType,
) -> bool:
    """Check if a TOML output failure should fall back to JSON.

    yq cannot encode nested/non-scalar structures as TOML output. When the output
    format was auto-selected (not explicit), this function identifies the specific
    error and signals the caller to retry with JSON output.

    Args:
        error: The YQExecutionError from the failed execution.
        output_format_explicit: Whether the user explicitly requested this output format.
        output_format: The output format that was used.
        input_format: The input file format.

    Returns:
        True if the caller should retry with FormatType.JSON output.
    """
    return (
        not output_format_explicit
        and output_format == FormatType.TOML
        and input_format == FormatType.TOML
        and "only scalars" in str(error.stderr)
    )
```

This requires importing `YQExecutionError` from the backends. Since `formats/base.py` already imports `FormatType` from `yq_wrapper`, also import `YQExecutionError` from the same place. Add to `__all__`.

**DRY-03b: `_navigate_to_parent()` in toml_utils.py**

Extract the shared key-path navigation logic:

```python
def _navigate_to_parent(
    data: MutableMapping[str, Any],
    key_path: str,
    *,
    create_missing: bool = False,
) -> tuple[MutableMapping[str, Any], str]:
    """Navigate a nested mapping to the parent of the target key.

    Args:
        data: Root mapping to navigate.
        key_path: Dot-separated key path (e.g., "database.port").
        create_missing: If True, create intermediate tables for missing keys.
            If False (default), raise KeyError on missing intermediate keys.

    Returns:
        Tuple of (parent_mapping, final_key_name).

    Raises:
        KeyError: If an intermediate key is missing and create_missing is False.
        TypeError: If an intermediate value is not a mapping (e.g., navigating through a string).
    """
    keys = key_path.split(".")
    current: MutableMapping[str, Any] = data
    for key in keys[:-1]:
        if key not in current:
            if create_missing:
                current[key] = {}
            else:
                raise KeyError(f"Key path '{key_path}' not found")
        nested = current[key]
        if not isinstance(nested, MutableMapping):
            msg = f"Cannot navigate through non-table value at key '{key}'"
            raise TypeError(msg)
        current = nested
    return current, keys[-1]
```

Then refactor `set_toml_value` and `delete_toml_key` to use it:

```python
def set_toml_value(file_path: Path, key_path: str, value: Any) -> str:
    content = file_path.read_text(encoding="utf-8")
    data = tomlkit.parse(content)
    parent, final_key = _navigate_to_parent(data, key_path, create_missing=True)
    parent[final_key] = value
    return tomlkit.dumps(data)

def delete_toml_key(file_path: Path, key_path: str) -> str:
    content = file_path.read_text(encoding="utf-8")
    data = tomlkit.parse(content)
    parent, final_key = _navigate_to_parent(data, key_path, create_missing=False)
    if final_key not in parent:
        raise KeyError(f"Key path '{key_path}' not found")
    del parent[final_key]
    return tomlkit.dumps(data)
```

  </action>
  <verify>
Run `uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q` -- all existing tests must pass. The utility functions are not yet called from the refactored sites, so this verifies no regressions from the new code in the utility modules.

Run `uv run prek run --files packages/mcp_json_yaml_toml/config.py packages/mcp_json_yaml_toml/formats/base.py packages/mcp_json_yaml_toml/toml_utils.py` to verify linting and type checking pass on the modified files.
</verify>
<done>Four new functions exist: `require_format_enabled` in config.py, `resolve_file_path` and `should_fallback_toml_to_json` in formats/base.py, `_navigate_to_parent` in toml_utils.py. All existing tests pass. `set_toml_value` and `delete_toml_key` use `_navigate_to_parent` internally.</done>
</task>

<task type="auto">
  <name>Task 2: Replace all duplicated call sites with shared utilities</name>
  <files>
    packages/mcp_json_yaml_toml/tools/data.py
    packages/mcp_json_yaml_toml/tools/query.py
    packages/mcp_json_yaml_toml/tools/convert.py
    packages/mcp_json_yaml_toml/tools/diff.py
    packages/mcp_json_yaml_toml/tools/schema.py
    packages/mcp_json_yaml_toml/services/data_operations.py
  </files>
  <action>
**Replace format-enable checks (DRY-01) -- 9 sites:**

In each file, replace the 4-line pattern:

```python
if not is_format_enabled(input_format):
    enabled = parse_enabled_formats()
    raise ToolError(
        f"Format '{input_format}' is not enabled. Enabled formats: {', '.join(f.value for f in enabled)}"
    )
```

with a single call:

```python
require_format_enabled(input_format)
```

Update imports accordingly. Add `require_format_enabled` to the import from `config`. Remove unused imports of `is_format_enabled` and `parse_enabled_formats` if they are no longer referenced in that file (note: `config.py` itself still defines them, and some files like `tools/convert.py` may still need `parse_enabled_formats` if they reference it elsewhere -- check each file individually).

Files and locations for format-enable check replacement:

1. `tools/query.py:68-72`
2. `tools/convert.py:60-64` (input format check)
3. `tools/convert.py:168-172` and `173-177` (merge format1 and format2 checks -- note the diff module has slightly different error messages mentioning "first file" and "second file"; keep the custom message by calling `require_format_enabled` and adjusting if needed, OR accept the standard message since it is clearer)
4. `tools/diff.py:62-67` and `68-73` (similar to convert -- two checks)
5. `tools/schema.py:37-41`
6. `services/data_operations.py:604-608`
7. `services/data_operations.py:671-675`
8. `services/data_operations.py:706-710`

Note on `tools/diff.py` and `tools/convert.py` (merge): These have slightly customized error messages ("Format of first file" vs "Format"). Replace with the standard `require_format_enabled()` which uses "Format '{format_type}' is not enabled" -- this is more consistent and equally informative since the format name itself identifies what was checked.

**Replace file path resolution (DRY-03a) -- all tool modules:**

In each tool file, replace the pattern:

```python
path = Path(file_path).expanduser().resolve()
if not path.exists():
    raise ToolError(f"File not found: {file_path}")
```

with:

```python
path = resolve_file_path(file_path)
```

Add `from mcp_json_yaml_toml.formats.base import resolve_file_path` to imports. Remove `from pathlib import Path` if no longer used directly (check each file -- some still need Path for output_file handling).

Files for path resolution replacement:

1. `tools/data.py:82-85`
2. `tools/query.py:61-64`
3. `tools/convert.py:53-56` (data_convert input file)
4. `tools/convert.py:156-162` (data_merge file1/file2)
5. `tools/diff.py:50-56` (file1/file2)
6. `tools/schema.py:32-34, 62-64, 107-111, 142-144, 177` (multiple schema actions -- use `resolve_file_path` for file checks. For directory checks at line 107-111, keep as-is since `resolve_file_path` is for files, not dirs. For line 177 where `.exists()` is not checked, use `resolve_file_path(file_path, must_exist=False)` to just get the resolved path.)

**Replace TOML fallback (DRY-02) -- 2 sites:**

In `tools/query.py`, replace the inline TOML fallback (lines 92-107):

```python
except YQExecutionError as e:
    if should_fallback_toml_to_json(e, output_format_explicit, output_format_value, input_format):
        result = execute_yq(
            expression,
            input_file=path,
            input_format=input_format,
            output_format=FormatType.JSON,
        )
        return _build_query_response(result, FormatType.JSON, path, cursor)
    raise ToolError(f"Query failed: {e}") from e
```

In `services/data_operations.py` (`_handle_data_get_value`), replace the recursive self-call fallback (lines 269-286):

```python
except YQExecutionError as e:
    if should_fallback_toml_to_json(e, output_format_explicit, output_fmt, input_format):
        return _handle_data_get_value(
            path, key_path, input_format, FormatType.JSON, cursor, schema_info,
            output_format_explicit=True,
        )
    raise ToolError(f"Query failed: {e}") from e
```

Add `from mcp_json_yaml_toml.formats.base import should_fallback_toml_to_json` to both files' imports.

Note: The recursive call in `_handle_data_get_value` is acceptable (bounded to one retry) and uses the shared predicate function. The key DRY win is the condition logic being in one place.
</action>
<verify>
Run `uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q` -- all tests must pass.

Run `uv run prek run --files packages/mcp_json_yaml_toml/tools/data.py packages/mcp_json_yaml_toml/tools/query.py packages/mcp_json_yaml_toml/tools/convert.py packages/mcp_json_yaml_toml/tools/diff.py packages/mcp_json_yaml_toml/tools/schema.py packages/mcp_json_yaml_toml/services/data_operations.py` to verify all linting and type checks pass.

Verify no remaining duplicates: Search for `is_format_enabled(` in tools/ and services/data_operations.py -- should find zero occurrences (only config.py should have the definition and require_format_enabled as sole consumer).

Verify path resolution: Search for `expanduser().resolve()` in tools/ -- should find only cases where `resolve_file_path` cannot be used (e.g., output file paths that may not exist yet, directory paths).
</verify>
<done>All 9 format-enable-check sites use `require_format_enabled()`. All file path resolution sites in tool modules use `resolve_file_path()`. Both TOML fallback sites use `should_fallback_toml_to_json()`. No remaining duplicated patterns. All tests and linters pass.</done>
</task>

</tasks>

<verification>
1. `uv run pytest packages/mcp_json_yaml_toml/tests/ -x -q` -- full test suite passes
2. `uv run prek run --files packages/mcp_json_yaml_toml/config.py packages/mcp_json_yaml_toml/formats/base.py packages/mcp_json_yaml_toml/toml_utils.py packages/mcp_json_yaml_toml/tools/data.py packages/mcp_json_yaml_toml/tools/query.py packages/mcp_json_yaml_toml/tools/convert.py packages/mcp_json_yaml_toml/tools/diff.py packages/mcp_json_yaml_toml/tools/schema.py packages/mcp_json_yaml_toml/services/data_operations.py` -- all gates pass
3. Grep for `if not is_format_enabled(` in `tools/` and `services/` returns 0 matches
4. Grep for `expanduser().resolve()` in `tools/` returns only output-path cases (not input validation)
5. Grep for `_navigate_to_parent` in `toml_utils.py` shows 3 hits (definition + 2 call sites)
</verification>

<success_criteria>

- DRY-01 complete: `require_format_enabled()` replaces 9 duplicated check blocks
- DRY-02 complete: `should_fallback_toml_to_json()` replaces 2 inline fallback conditions
- DRY-03 complete: `resolve_file_path()` replaces 10+ path resolution blocks; `_navigate_to_parent()` replaces 2 navigation blocks
- Zero test regressions
- All lint and type check gates pass
  </success_criteria>

<output>
After completion, create `.planning/phases/05-type-safety-and-dry-foundation/05-01-SUMMARY.md`
</output>
