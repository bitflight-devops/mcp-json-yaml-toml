---
phase: 08-test-quality
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - packages/mcp_json_yaml_toml/tests/test_config.py
  - packages/mcp_json_yaml_toml/tests/test_diff.py
  - packages/mcp_json_yaml_toml/tests/test_fastmcp_integration.py
  - packages/mcp_json_yaml_toml/tests/test_lmql_constraints.py
  - packages/mcp_json_yaml_toml/tests/test_pagination.py
  - packages/mcp_json_yaml_toml/tests/test_schema_detection.py
  - packages/mcp_json_yaml_toml/tests/test_schemas.py
  - packages/mcp_json_yaml_toml/tests/test_server.py
  - packages/mcp_json_yaml_toml/tests/test_telemetry.py
  - packages/mcp_json_yaml_toml/tests/test_yaml_optimizer.py
  - packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py
autonomous: true

must_haves:
  truths:
    - "Test names follow behavioral pattern test_<what>_when_<condition>_then_<outcome>"
    - "Edge case tests exist for permission errors, malformed input, and resource cleanup"
    - "All existing tests continue to pass after renaming"
  artifacts:
    - path: "packages/mcp_json_yaml_toml/tests/test_server.py"
      provides: "Behaviorally-named tests for all MCP tool operations"
    - path: "packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py"
      provides: "Behaviorally-named tests plus edge case coverage"
    - path: "packages/mcp_json_yaml_toml/tests/test_pagination.py"
      provides: "Behaviorally-named pagination tests plus edge cases"
  key_links:
    - from: "packages/mcp_json_yaml_toml/tests/test_server.py"
      to: "packages/mcp_json_yaml_toml/server.py"
      via: "Public tool function calls (data_query, data, etc.)"
      pattern: "data_query_fn|data_fn|data_diff_fn"
---

<objective>
Standardize test naming to behavioral pattern and add edge case test coverage.

Purpose: Address TEST-02 (behavioral naming standardization) and TEST-03 (edge case coverage) requirements. Consistent naming makes test intent self-documenting. Edge case tests catch failure modes that the happy-path tests miss.

Output: Renamed tests across all test files following the `test_<what>_when_<condition>_then_<outcome>` pattern, plus new edge case tests for permissions, malformed input, and resource cleanup.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-test-quality/08-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Standardize test naming in smaller test files</name>
  <files>
    packages/mcp_json_yaml_toml/tests/test_config.py
    packages/mcp_json_yaml_toml/tests/test_diff.py
    packages/mcp_json_yaml_toml/tests/test_fastmcp_integration.py
    packages/mcp_json_yaml_toml/tests/test_schema_detection.py
    packages/mcp_json_yaml_toml/tests/test_telemetry.py
  </files>
  <action>
Rename test methods in the 5 smaller test files to follow `test_<what>_when_<condition>_then_<outcome>` pattern. Do NOT rename test files or class names -- only method names.

**Pattern:** `test_<what>_when_<condition>_then_<outcome>`

- `<what>`: the function/feature being tested (e.g., `data_query`, `parse_version`, `cursor_encoding`)
- `<condition>`: the scenario or input (e.g., `given_valid_json`, `with_missing_file`, `when_env_not_set`)
- `<outcome>`: the expected result (e.g., `returns_result`, `raises_tool_error`, `returns_defaults`)

**Renaming examples per file:**

test_config.py:

- `test_parse_enabled_formats_default` -> `test_parse_enabled_formats_when_env_not_set_then_returns_defaults`
- `test_parse_enabled_formats_single_format` -> `test_parse_enabled_formats_when_single_format_set_then_returns_only_that_format`
- `test_is_format_enabled_json` -> `test_is_format_enabled_when_json_then_returns_true`

test_diff.py:

- `test_identical_json_files` -> `test_data_diff_when_identical_json_files_then_no_differences`
- `test_cross_format_json_vs_yaml` -> `test_data_diff_when_cross_format_same_content_then_no_differences`

test_fastmcp_integration.py:

- `test_data_query_json` -> `test_data_query_when_json_via_mcp_protocol_then_returns_result`
- `test_error_handling_missing_file` -> `test_data_query_when_missing_file_via_mcp_protocol_then_returns_error`

test_schema_detection.py:

- `test_detect_schema_json` -> `test_detect_schema_when_json_with_schema_url_then_returns_schema_info`

test_telemetry.py:

- Apply same pattern to all test methods in that file.

**Rules:**

1. Rename ONLY methods, not classes or files
2. Update docstrings to match new names where they reference the old name
3. If a test was already parametrized in Plan 01, rename the parametrized method too
4. Keep existing test logic unchanged -- this is ONLY a naming refactor
5. Names that already follow the pattern can be left as-is (some tests from Plan 01 may already follow it)
6. Do NOT touch test_set_type_preservation.py, test_no_anchor_files.py, test_toml_formatting.py, test_toml_write.py, test_yaml_optimization_integration.py -- these files are small/specialized and their existing names are adequate
   </action>
   <verify>

```bash
# Run tests in the 5 modified files
uv run pytest packages/mcp_json_yaml_toml/tests/test_config.py packages/mcp_json_yaml_toml/tests/test_diff.py packages/mcp_json_yaml_toml/tests/test_fastmcp_integration.py packages/mcp_json_yaml_toml/tests/test_schema_detection.py packages/mcp_json_yaml_toml/tests/test_telemetry.py -v --no-header 2>&1 | tail -20

# Spot-check naming pattern adoption
grep -c "def test_.*_when_.*_then_" packages/mcp_json_yaml_toml/tests/test_config.py packages/mcp_json_yaml_toml/tests/test_diff.py packages/mcp_json_yaml_toml/tests/test_fastmcp_integration.py packages/mcp_json_yaml_toml/tests/test_schema_detection.py packages/mcp_json_yaml_toml/tests/test_telemetry.py
```

All tests pass. Majority of test methods in the 5 files now follow the behavioral naming pattern.
</verify>
<done>
Test method names in 5 smaller test files follow `test_<what>_when_<condition>_then_<outcome>` pattern. All tests pass after renaming. No behavioral changes.
</done>
</task>

<task type="auto">
  <name>Task 1b: Standardize test naming in larger test files (batch 1)</name>
  <files>
    packages/mcp_json_yaml_toml/tests/test_schemas.py
    packages/mcp_json_yaml_toml/tests/test_server.py
    packages/mcp_json_yaml_toml/tests/test_pagination.py
  </files>
  <action>
Rename test methods in 3 larger test files to follow `test_<what>_when_<condition>_then_<outcome>` pattern. Do NOT rename test files or class names -- only method names.

**Pattern:** `test_<what>_when_<condition>_then_<outcome>`

- `<what>`: the function/feature being tested (e.g., `data_query`, `parse_version`, `cursor_encoding`)
- `<condition>`: the scenario or input (e.g., `given_valid_json`, `with_missing_file`, `when_env_not_set`)
- `<outcome>`: the expected result (e.g., `returns_result`, `raises_tool_error`, `returns_defaults`)

**Renaming examples per file:**

test_server.py:

- `test_data_query_json_success` -> `test_data_query_when_valid_json_then_returns_result`
- `test_data_query_file_not_found` -> `test_data_query_when_file_missing_then_raises_tool_error`
- `test_data_set_simple_value` -> `test_data_set_when_simple_value_then_updates_file`

test_pagination.py:

- `test_cursor_roundtrip` -> `test_cursor_encoding_when_roundtrip_then_preserves_offset`
- `test_cursor_opaque` -> `test_cursor_encoding_when_encoded_then_not_plain_integer`
- `test_small_data_no_pagination` -> `test_paginate_result_when_data_below_page_size_then_no_pagination`

test_schemas.py:

- `test_loads_patterns_from_bundled_file` -> `test_load_default_ide_patterns_when_called_then_returns_nonempty_list`
- `test_each_pattern_is_glob` -> `test_load_default_ide_patterns_when_called_then_all_patterns_contain_glob_chars`

**Rules:**

1. Rename ONLY methods, not classes or files
2. Update docstrings to match new names where they reference the old name
3. If a test was already parametrized in Plan 01, rename the parametrized method too
4. Keep existing test logic unchanged -- this is ONLY a naming refactor
5. Names that already follow the pattern can be left as-is (some tests from Plan 01 may already follow it)
   </action>
   <verify>

```bash
# Run tests in the 3 modified files
uv run pytest packages/mcp_json_yaml_toml/tests/test_schemas.py packages/mcp_json_yaml_toml/tests/test_server.py packages/mcp_json_yaml_toml/tests/test_pagination.py -v --no-header 2>&1 | tail -20

# Spot-check naming pattern adoption
grep -c "def test_.*_when_.*_then_" packages/mcp_json_yaml_toml/tests/test_server.py packages/mcp_json_yaml_toml/tests/test_pagination.py packages/mcp_json_yaml_toml/tests/test_schemas.py
```

All tests pass. Majority of test methods in the 3 files now follow the behavioral naming pattern.
</verify>
<done>
Test method names in test*schemas.py, test_server.py, and test_pagination.py follow `test*<what>_when_<condition>_then_<outcome>` pattern. All tests pass after renaming. No behavioral changes.
</done>
</task>

<task type="auto">
  <name>Task 1c: Standardize test naming in larger test files (batch 2)</name>
  <files>
    packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py
    packages/mcp_json_yaml_toml/tests/test_lmql_constraints.py
    packages/mcp_json_yaml_toml/tests/test_yaml_optimizer.py
  </files>
  <action>
Rename test methods in 3 larger test files to follow `test_<what>_when_<condition>_then_<outcome>` pattern. Do NOT rename test files or class names -- only method names.

**Pattern:** `test_<what>_when_<condition>_then_<outcome>`

- `<what>`: the function/feature being tested (e.g., `data_query`, `parse_version`, `cursor_encoding`)
- `<condition>`: the scenario or input (e.g., `given_valid_json`, `with_missing_file`, `when_env_not_set`)
- `<outcome>`: the expected result (e.g., `returns_result`, `raises_tool_error`, `returns_defaults`)

**Renaming examples per file:**

test_yq_wrapper.py:

- `test_get_yq_binary_path_returns_path` -> `test_get_yq_binary_path_when_called_then_returns_path_object`
- `test_execute_yq_with_input_data` -> `test_execute_yq_when_input_data_provided_then_passes_to_subprocess`
- `test_verify_checksum_returns_true_for_matching_hash` -> `test_verify_checksum_when_hash_matches_then_returns_true`

test_lmql_constraints.py:

- `test_valid_simple_path` -> `test_yq_path_constraint_when_simple_path_then_valid`
- `test_empty_path` -> `test_yq_path_constraint_when_empty_then_partial_with_suggestions`

test_yaml_optimizer.py:

- `test_find_duplicates_simple_dict` -> `test_find_duplicates_when_simple_dict_then_finds_repeated_values`
- `test_optimize_yaml_creates_anchors` -> `test_optimize_yaml_when_duplicates_present_then_creates_anchors`

**Rules:**

1. Rename ONLY methods, not classes or files
2. Update docstrings to match new names where they reference the old name
3. If a test was already parametrized in Plan 01, rename the parametrized method too â€” note that Plan 01 adds @pytest.mark.parametrize to these files, so test output may show bracket notation (e.g., `test_yq_path_constraint_when_valid_path_then_valid[.name]`). This is expected.
4. Keep existing test logic unchanged -- this is ONLY a naming refactor
5. Names that already follow the pattern can be left as-is (some tests from Plan 01 may already follow it)
   </action>
   <verify>

```bash
# Run tests in the 3 modified files
uv run pytest packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py packages/mcp_json_yaml_toml/tests/test_lmql_constraints.py packages/mcp_json_yaml_toml/tests/test_yaml_optimizer.py -v --no-header 2>&1 | tail -20

# Spot-check naming pattern adoption
grep -c "def test_.*_when_.*_then_" packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py packages/mcp_json_yaml_toml/tests/test_lmql_constraints.py packages/mcp_json_yaml_toml/tests/test_yaml_optimizer.py
```

All tests pass. Majority of test methods in the 3 files now follow the behavioral naming pattern.
</verify>
<done>
Test method names in test*yq_wrapper.py, test_lmql_constraints.py, and test_yaml_optimizer.py follow `test*<what>_when_<condition>_then_<outcome>` pattern. All tests pass after renaming. No behavioral changes.
</done>
</task>

<task type="auto">
  <name>Task 2: Add edge case tests for permissions, malformed input, and resource cleanup</name>
  <files>
    packages/mcp_json_yaml_toml/tests/test_server.py
    packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py
    packages/mcp_json_yaml_toml/tests/test_pagination.py
  </files>
  <action>
Add edge case tests to EXISTING test files. Do NOT create new test files. Use the behavioral naming pattern from Task 1.

**test_server.py -- Add to end of file (new test class):**

```python
class TestEdgeCases:
    """Edge case tests for MCP tool error handling."""
```

Add these tests:

1. **Permission error test:**

   ```python
   def test_data_query_when_file_not_readable_then_raises_error(self, tmp_path):
   ```

   Create a JSON file, set permissions to 0o000 (write-only), attempt `data_query_fn(str(file), ".")`, assert ToolError is raised. Use `pytest.mark.skipif(os.getuid() == 0, reason="root bypasses permissions")` to skip on root. Restore permissions in finally block (or use monkeypatch).

2. **Malformed input -- binary content:**

   ```python
   def test_data_query_when_binary_file_then_raises_error(self, tmp_path):
   ```

   Create a file with random binary content (bytes(range(256))), give it .json extension, attempt `data_query_fn()`, assert error is raised (ToolError or similar).

3. **Malformed input -- BOM marker:**

   ```python
   def test_data_query_when_json_with_bom_then_handles_gracefully(self, tmp_path):
   ```

   Create a JSON file with UTF-8 BOM prefix (`b'\xef\xbb\xbf' + b'{"key": "value"}'`), attempt `data_query_fn()`. Use a try/except block: if it succeeds, assert result contains `"result"` key with non-empty value. If it raises ToolError, assert the error message is non-empty (not an unhandled crash). Either outcome is acceptable -- the test verifies graceful handling, not a specific result.

4. **Empty file:**
   ```python
   def test_data_query_when_empty_file_then_raises_error(self, tmp_path):
   ```
   Create a 0-byte .json file, attempt `data_query_fn()`, assert error is raised.

**test_yq_wrapper.py -- Add to existing classes or new class at end:**

5. **Subprocess timeout edge case:**

   ```python
   def test_execute_yq_when_very_long_expression_then_handles_gracefully(self, sample_json_config):
   ```

   Pass an extremely long (but valid) yq expression like `"." + " | ." * 100`, verify it either succeeds or raises a clear error (not an unhandled exception).

6. **Binary path with spaces:**
   ```python
   def test_get_yq_binary_path_when_path_contains_spaces_then_still_works(self, tmp_path, monkeypatch):
   ```
   Create a directory with spaces in the name under tmp_path, copy/symlink the yq binary there, set YQ_BINARY_PATH env var to point to it, verify `get_yq_binary_path()` returns the path and the binary is valid.

**test_pagination.py -- Add to TestPaginateResult or new class:**

7. **Unicode pagination boundary:**

   ```python
   def test_paginate_result_when_multibyte_unicode_at_boundary_then_no_corruption(self):
   ```

   Create a string with multibyte Unicode characters (e.g., emoji, CJK) that lands exactly at a page boundary. Verify pagination doesn't split in the middle of a multibyte character (check that concatenating all pages produces the original string).

8. **Very large cursor offset (parametrized):**
   ```python
   @pytest.mark.parametrize("offset", [999999, 2**31, 2**53])
   def test_paginate_result_when_cursor_beyond_content_then_raises_error(self, offset):
   ```
   Create a small data string (e.g., `"test data"`), encode a cursor with each large offset, call `paginate_result()` with that cursor, and assert it raises an error or returns empty/error response. This tests offset boundary handling at multiple scales.

**test_yq_wrapper.py -- Resource cleanup tests (TEST-03):**

9. **Subprocess cleanup after failed yq call:**

   ```python
   def test_execute_yq_when_invalid_expression_then_subprocess_resources_cleaned_up(self, sample_json_config):
   ```

   Call `execute_yq` with a deliberately invalid expression (e.g., `"invalid[[["`). After the call returns (with error), run `gc.collect()` and use `warnings.catch_warnings(record=True)` to capture any ResourceWarning. Assert that no ResourceWarning referencing subprocess or file descriptors is raised. This verifies that subprocess.run properly completed and no resources leaked.

10. **Temp file cleanup during test execution:**

    ```python
    def test_execute_yq_when_input_data_provided_then_no_temp_files_remain(self, tmp_path):
    ```

    Call `execute_yq` with `input_data` parameter (which may create temporary files internally). After the call, list files in the system temp directory (or `tmp_path`) and verify no yq-related temp files remain. Use `tempfile.gettempdir()` and check that no new files matching `yq*` or `tmp*` patterns were created that persist after the call completes.

**All new tests must:**

- Follow `test_<what>_when_<condition>_then_<outcome>` naming
- Have docstrings with Tests/How/Why format
- Use existing fixtures where applicable (sample_json_config, tmp_path)
- Use proper cleanup (pytest fixtures handle this automatically with tmp_path)
- Include `# Arrange`, `# Act`, `# Assert` comments
  </action>
  <verify>

```bash
# Run just the new edge case tests
uv run pytest packages/mcp_json_yaml_toml/tests/test_server.py::TestEdgeCases -v --no-header 2>&1
uv run pytest packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py -k "edge or cleanup or temp_files" -v --no-header 2>&1
uv run pytest packages/mcp_json_yaml_toml/tests/test_pagination.py -k "unicode" -v --no-header 2>&1

# Full test suite
uv run pytest --no-header -q 2>&1 | tail -10

# Lint all modified files
uv run prek run --files packages/mcp_json_yaml_toml/tests/test_server.py packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py packages/mcp_json_yaml_toml/tests/test_pagination.py
```

All new edge case tests pass. No regressions in existing tests. Linting passes.
</verify>
<done>
Edge case tests added: permission errors, binary/malformed input, BOM handling, empty files, long expressions, path-with-spaces, Unicode pagination boundaries, subprocess resource cleanup, and temp file cleanup. All tests follow behavioral naming pattern with proper docstrings and cleanup.
</done>
</task>

</tasks>

<verification>
**Note:** Plan 01 adds @pytest.mark.parametrize to test_diff.py, test_lmql_constraints.py, and test_yq_wrapper.py. After Plan 01 executes, test output for these files will show bracket notation (e.g., `test_yq_path_constraint_when_valid_path_then_valid[.name]`). This is expected and correct -- the parametrized method names from Plan 01 get renamed in Tasks 1a/1c here.

```bash
# Full test suite
uv run pytest --no-header -q 2>&1 | tail -10

# Verify behavioral naming adoption rate (target: >80% of test methods contain "when" and "then")

grep -c "def test*.\*\_when*.\*_then_" packages/mcp_json_yaml_toml/tests/test_server.py packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py packages/mcp_json_yaml_toml/tests/test_config.py packages/mcp_json_yaml_toml/tests/test_pagination.py packages/mcp_json_yaml_toml/tests/test_diff.py packages/mcp_json_yaml_toml/tests/test_schemas.py packages/mcp_json_yaml_toml/tests/test_lmql_constraints.py

# Verify edge case tests exist

grep -c "class TestEdgeCases" packages/mcp_json_yaml_toml/tests/test_server.py

# Run linting on all modified files

uv run prek run --files packages/mcp_json_yaml_toml/tests/test_config.py packages/mcp_json_yaml_toml/tests/test_diff.py packages/mcp_json_yaml_toml/tests/test_fastmcp_integration.py packages/mcp_json_yaml_toml/tests/test_lmql_constraints.py packages/mcp_json_yaml_toml/tests/test_pagination.py packages/mcp_json_yaml_toml/tests/test_schema_detection.py packages/mcp_json_yaml_toml/tests/test_schemas.py packages/mcp_json_yaml_toml/tests/test_server.py packages/mcp_json_yaml_toml/tests/test_telemetry.py packages/mcp_json_yaml_toml/tests/test_yaml_optimizer.py packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py

```

</verification>

<success_criteria>

1. Majority (>80%) of test methods in targeted files follow `test_<what>_when_<condition>_then_<outcome>` pattern
2. Edge case tests exist for: permission errors, malformed/binary input, BOM handling, empty files, Unicode pagination, subprocess resource cleanup, temp file cleanup
3. All tests pass (existing + new)
4. All linting gates pass
5. No behavioral changes to existing tests (only names changed)
   </success_criteria>

<output>
After completion, create `.planning/phases/08-test-quality/08-02-SUMMARY.md`
</output>
```
