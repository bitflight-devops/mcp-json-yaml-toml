---
phase: 01-architectural-foundation
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - packages/mcp_json_yaml_toml/backends/binary_manager.py
  - packages/mcp_json_yaml_toml/backends/yq.py
  - packages/mcp_json_yaml_toml/backends/__init__.py
  - packages/mcp_json_yaml_toml/yq_wrapper.py
autonomous: true
must_haves:
  truths:
    - "yq binary lifecycle management is decoupled from query execution (ARCH-03)"
    - "YqBackend class implements QueryBackend protocol with execute() and validate() methods (ARCH-04)"
    - "yq_wrapper.py is a backward-compatible shim re-exporting all public symbols"
    - "All 395 existing tests pass without modification including test_yq_wrapper.py"
    - "server.py continues to call execute_yq() via the shim without changes"
  artifacts:
    - path: "packages/mcp_json_yaml_toml/backends/binary_manager.py"
      provides: "Binary discovery, download, verification, version management, caching"
      exports: ["get_yq_binary_path", "get_yq_version", "validate_yq_binary"]
    - path: "packages/mcp_json_yaml_toml/backends/yq.py"
      provides: "YqBackend class and module-level execute_yq function"
      exports: ["YqBackend", "execute_yq", "parse_yq_error"]
    - path: "packages/mcp_json_yaml_toml/yq_wrapper.py"
      provides: "Backward-compatible shim re-exporting all public symbols from backends/"
      contains: "from mcp_json_yaml_toml.backends"
  key_links:
    - from: "packages/mcp_json_yaml_toml/backends/yq.py"
      to: "packages/mcp_json_yaml_toml/backends/binary_manager.py"
      via: "YqBackend calls get_yq_binary_path for binary resolution"
      pattern: "from mcp_json_yaml_toml\\.backends\\.binary_manager import"
    - from: "packages/mcp_json_yaml_toml/backends/yq.py"
      to: "packages/mcp_json_yaml_toml/backends/base.py"
      via: "Imports FormatType, YQResult, error types from base"
      pattern: "from mcp_json_yaml_toml\\.backends\\.base import"
    - from: "packages/mcp_json_yaml_toml/yq_wrapper.py"
      to: "packages/mcp_json_yaml_toml/backends/"
      via: "Shim re-exports all public symbols from backends submodules"
      pattern: "from mcp_json_yaml_toml\\.backends\\."
    - from: "packages/mcp_json_yaml_toml/server.py"
      to: "packages/mcp_json_yaml_toml/yq_wrapper.py"
      via: "server.py imports execute_yq, FormatType, errors from yq_wrapper shim"
      pattern: "from mcp_json_yaml_toml\\.yq_wrapper import"
---

<objective>
Extract binary lifecycle management and query execution from yq_wrapper.py into backends/binary_manager.py and backends/yq.py, then convert yq_wrapper.py to a backward-compatible shim.

Purpose: This is the core architectural extraction (ARCH-03 + ARCH-04). Binary management (~663 lines: discovery, download, verification, caching) is decoupled from query execution (~269 lines: subprocess invocation, argument building, output parsing). The YqBackend class wraps execute_yq as an implementation of the QueryBackend protocol from Plan 01. yq_wrapper.py becomes a ~30-line shim that re-exports all public symbols, preserving all existing import paths for server.py (14+ call sites) and test_yq_wrapper.py (20+ imports).

Output: backends/binary_manager.py, backends/yq.py, yq_wrapper.py shim. yq_wrapper.py shrinks from 934 to ~30 lines.
</objective>

<execution_context>
@/home/ubuntulinuxqa2/.claude/get-shit-done/workflows/execute-plan.md
@/home/ubuntulinuxqa2/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-architectural-foundation/01-RESEARCH.md
@.planning/phases/01-architectural-foundation/01-01-SUMMARY.md
@.planning/codebase/CONVENTIONS.md
@packages/mcp_json_yaml_toml/yq_wrapper.py
@packages/mcp_json_yaml_toml/backends/base.py
@packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract binary_manager.py and yq.py from yq_wrapper.py</name>
  <files>
    packages/mcp_json_yaml_toml/backends/binary_manager.py
    packages/mcp_json_yaml_toml/backends/yq.py
    packages/mcp_json_yaml_toml/backends/__init__.py
  </files>
  <action>
Read yq_wrapper.py carefully and extract into two new modules.

**backends/binary_manager.py** -- Binary lifecycle management (lines 1-663 of yq_wrapper.py):

Move ALL binary-related functions and constants:

- Constants: `GITHUB_REPO`, `DEFAULT_YQ_VERSION`, `DEFAULT_YQ_CHECKSUMS`, `CHECKSUM_MIN_FIELDS`, `CHECKSUM_MAX_FIELDS`, `CHECKSUM_HASH_FIELD`, `CHECKSUM_FILENAME_FIELD`
- Binary discovery: `get_yq_binary_path`, `_find_system_yq`, `_get_storage_location`
- Version management: `get_yq_version`, `_get_yq_version_string`, `_is_mikefarah_yq`, `_parse_version`, `_version_meets_minimum`
- Download/verify: `_download_yq_binary`, `_download_file`, `_get_checksums`, `_fetch_checksums_from_github`, `_verify_checksum`, `_cleanup_old_versions`
- Platform detection: `_get_platform_binary_info`, `_get_download_headers`
- Validation: `validate_yq_binary`

Imports needed: Standard library (pathlib, platform, subprocess, hashlib, os, shutil, uuid, stat, logging, struct), httpx, portalocker. Import `YQBinaryNotFoundError` from `mcp_json_yaml_toml.backends.base`.

This module has zero circular dependency risk: it imports only from base.py (a leaf module) and stdlib/third-party.

**backends/yq.py** -- Query execution (lines 665-934 of yq_wrapper.py):

Move ALL query execution functions:

- `execute_yq` -- main entry point (keep as module-level function for backward compatibility)
- `_validate_execute_args` -- argument validation
- `_build_yq_command` -- command construction
- `_run_yq_subprocess` -- subprocess execution
- `_parse_json_output` -- output parsing
- `parse_yq_error` -- error message formatting

Create `YqBackend` class implementing `QueryBackend` protocol:

```python
class YqBackend:
    """yq-based query backend implementing QueryBackend protocol."""

    def execute(
        self,
        expression: str,
        input_data: str | None = None,
        input_file: Path | str | None = None,
        input_format: FormatType = FormatType.YAML,
        output_format: FormatType = FormatType.JSON,
        in_place: bool = False,
        null_input: bool = False,
    ) -> YQResult:
        """Execute a yq expression."""
        return execute_yq(
            expression=expression,
            input_data=input_data,
            input_file=input_file,
            input_format=input_format,
            output_format=output_format,
            in_place=in_place,
            null_input=null_input,
        )

    def validate(self) -> tuple[bool, str]:
        """Validate the yq binary is available and functional."""
        return validate_yq_binary()
```

Imports needed: From `mcp_json_yaml_toml.backends.base` import FormatType, YQResult, YQError, YQExecutionError, YQBinaryNotFoundError. From `mcp_json_yaml_toml.backends.binary_manager` import get_yq_binary_path, validate_yq_binary.

**backends/**init**.py** -- Update to export key symbols:

```python
"""Backend abstraction layer for query execution engines."""

from mcp_json_yaml_toml.backends.base import QueryBackend

__all__ = ["QueryBackend"]
```

Follow project conventions: `from __future__ import annotations` first, Google-style docstrings, type annotations. Preserve ALL `# pragma: no cover` comments on platform-specific/download code. Preserve ALL `# noqa` comments.

IMPORTANT: Do NOT modify yq_wrapper.py in this task. That happens in Task 2.
</action>
<verify>
Run: `python -c "from mcp_json_yaml_toml.backends.binary_manager import get_yq_binary_path, get_yq_version, validate_yq_binary; print('binary_manager OK')"` -- must succeed.

Run: `python -c "from mcp_json_yaml_toml.backends.yq import YqBackend, execute_yq, parse_yq_error; print('yq OK')"` -- must succeed.

Run: `python -c "from mcp_json_yaml_toml.backends import QueryBackend; print('backends init OK')"` -- must succeed.

Run: `uv run ruff check packages/mcp_json_yaml_toml/backends/` -- must pass.

Run: `uv run ruff format --check packages/mcp_json_yaml_toml/backends/` -- must pass.

Run: `uv run pytest -x -q` -- all 395 tests must still pass (yq_wrapper.py unchanged, still has original definitions).
</verify>
<done>
backends/binary_manager.py contains all binary lifecycle management. backends/yq.py contains YqBackend class and execute_yq function. Both modules import cleanly. All existing tests still pass.
</done>
</task>

<task type="auto">
  <name>Task 2: Convert yq_wrapper.py to backward-compatible shim</name>
  <files>packages/mcp_json_yaml_toml/yq_wrapper.py</files>
  <action>
Replace the entire contents of yq_wrapper.py with a backward-compatible shim module that re-exports all public symbols from the backends/ submodules.

**The shim must re-export every symbol that test_yq_wrapper.py imports.** From the test file imports:

```python
from mcp_json_yaml_toml.yq_wrapper import (
    DEFAULT_YQ_CHECKSUMS,
    DEFAULT_YQ_VERSION,
    FormatType,
    YQBinaryNotFoundError,
    YQError,
    YQExecutionError,
    YQResult,
    _cleanup_old_versions,
    _find_system_yq,
    _get_checksums,
    _get_platform_binary_info,
    _is_mikefarah_yq,
    _parse_version,
    _verify_checksum,
    _version_meets_minimum,
    execute_yq,
    get_yq_binary_path,
    get_yq_version,
    parse_yq_error,
    validate_yq_binary,
)
```

**Also re-export symbols imported by server.py:**

- `FormatType`, `YQError`, `YQExecutionError`, `execute_yq` (confirmed by grep of server.py imports)

**Also re-export symbols imported by config.py and test_config.py:**

- `FormatType` (confirmed by grep)

**Shim structure:**

```python
"""Backward-compatible shim. Real implementation in backends/.

This module re-exports all public symbols from the backends/ package
to maintain backward compatibility with existing import paths.
New code should import directly from mcp_json_yaml_toml.backends.
"""

from __future__ import annotations

from mcp_json_yaml_toml.backends.base import (  # noqa: F401
    FormatType,
    YQBinaryNotFoundError,
    YQError,
    YQExecutionError,
    YQResult,
)
from mcp_json_yaml_toml.backends.binary_manager import (  # noqa: F401
    DEFAULT_YQ_CHECKSUMS,
    DEFAULT_YQ_VERSION,
    _cleanup_old_versions,
    _find_system_yq,
    _get_checksums,
    _get_platform_binary_info,
    _is_mikefarah_yq,
    _parse_version,
    _verify_checksum,
    _version_meets_minimum,
    get_yq_binary_path,
    get_yq_version,
    validate_yq_binary,
)
from mcp_json_yaml_toml.backends.yq import (  # noqa: F401
    execute_yq,
    parse_yq_error,
)

__all__ = [
    "DEFAULT_YQ_CHECKSUMS",
    "DEFAULT_YQ_VERSION",
    "FormatType",
    "YQBinaryNotFoundError",
    "YQError",
    "YQExecutionError",
    "YQResult",
    "execute_yq",
    "get_yq_binary_path",
    "get_yq_version",
    "parse_yq_error",
    "validate_yq_binary",
]
```

Note: The `# noqa: F401` comments are needed because ruff will flag re-exports as unused imports. Alternatively, if the project's ruff config handles re-exports differently, check `pyproject.toml` for `[tool.ruff.lint.isort]` or `[tool.ruff.lint.per-file-ignores]` settings. The `__all__` list also helps ruff understand these are intentional re-exports.

CRITICAL: Verify EVERY import from test*yq_wrapper.py resolves through the shim. The test file imports private functions (prefixed with `*`) -- these MUST be re-exported too. Missing any single re-export will cause a test failure.

After writing the shim, run the full test suite to verify backward compatibility.
</action>
<verify>
Run: `uv run pytest -x -q` -- all 395 tests must pass.

Run: `uv run pytest packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py -v` -- all yq_wrapper tests must pass.

Run: `python -c "from mcp_json_yaml_toml.yq_wrapper import FormatType, execute_yq, YQResult, YQError, get_yq_binary_path, DEFAULT_YQ_VERSION; print('Shim backward compat OK')"` -- must succeed.

Run: `wc -l packages/mcp_json_yaml_toml/yq_wrapper.py` -- should be approximately 30-50 lines (down from 934).

Run: `uv run mypy packages/mcp_json_yaml_toml/yq_wrapper.py packages/mcp_json_yaml_toml/backends/ --show-error-codes` -- must pass.

Run: `uv run basedpyright packages/mcp_json_yaml_toml/yq_wrapper.py packages/mcp_json_yaml_toml/backends/` -- must pass.

Run: `uv run ruff check packages/mcp_json_yaml_toml/yq_wrapper.py packages/mcp_json_yaml_toml/backends/` -- must pass.
</verify>
<done>
yq_wrapper.py is a ~30-50 line shim re-exporting all symbols from backends/. All 395 tests pass including test_yq_wrapper.py. server.py continues to work without changes. Type checkers and linters pass. ARCH-03 (binary lifecycle decoupled) and ARCH-04 (QueryBackend with YqBackend implementation) requirements satisfied.
</done>
</task>

</tasks>

<verification>
1. `uv run pytest -x -q` -- all 395 tests pass
2. `uv run pytest packages/mcp_json_yaml_toml/tests/test_yq_wrapper.py -v` -- all pass
3. `python -c "from mcp_json_yaml_toml.yq_wrapper import FormatType, execute_yq, YQResult"` succeeds (backward compat)
4. `python -c "from mcp_json_yaml_toml.backends.yq import YqBackend; b = YqBackend(); print(type(b))"` succeeds
5. `python -c "from mcp_json_yaml_toml.backends.base import QueryBackend; print('Protocol OK')"` succeeds
6. `wc -l packages/mcp_json_yaml_toml/yq_wrapper.py` -- approximately 30-50 lines
7. Type checkers pass on all backends/ files and yq_wrapper.py shim
</verification>

<success_criteria>

- backends/binary_manager.py contains all binary lifecycle management (~663 lines from yq_wrapper.py)
- backends/yq.py contains YqBackend class and execute_yq function (~269 lines from yq_wrapper.py)
- YqBackend implements QueryBackend protocol with execute() and validate() methods
- yq_wrapper.py is a backward-compatible shim (~30-50 lines, down from 934)
- All 395 tests pass without modification (including test_yq_wrapper.py and server-level tests)
- Type checkers pass on all new and modified files
  </success_criteria>

<output>
After completion, create `.planning/phases/01-architectural-foundation/01-03-SUMMARY.md`
</output>
